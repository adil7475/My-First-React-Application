{"ast":null,"code":"'use strict'; // Load modules\n\nvar _toConsumableArray = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar Hoek = require('hoek');\n\nvar Topo = require('topo');\n\nvar Any = require('../any');\n\nvar Errors = require('../../errors');\n\nvar Cast = require('../../cast');\n\nvar State = require('../state'); // Declare internals\n\n\nvar internals = {};\n\ninternals.Object = /*#__PURE__*/function (_Any) {\n  _inherits(_class, _Any);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this));\n    _this._type = 'object';\n    _this._inner.children = null;\n    _this._inner.renames = [];\n    _this._inner.dependencies = [];\n    _this._inner.patterns = [];\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: \"_init\",\n    value: function _init() {\n      return arguments.length ? this.keys.apply(this, arguments) : this;\n    }\n  }, {\n    key: \"_base\",\n    value: function _base(value, state, options) {\n      var target = value;\n      var errors = [];\n\n      var finish = function finish() {\n        return {\n          value: target,\n          errors: errors.length ? errors : null\n        };\n      };\n\n      if (typeof value === 'string' && options.convert) {\n        value = internals.safeParse(value);\n      }\n\n      var type = this._flags.func ? 'function' : 'object';\n\n      if (!value || typeof value !== type || Array.isArray(value)) {\n        errors.push(this.createError(type + '.base', {\n          value: value\n        }, state, options));\n        return finish();\n      } // Skip if there are no other rules to test\n\n\n      if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children && // null allows any keys\n      !this._inner.patterns.length) {\n        target = value;\n        return finish();\n      } // Ensure target is a local copy (parsed) or shallow copy\n\n\n      if (target === value) {\n        if (type === 'object') {\n          target = Object.create(Object.getPrototypeOf(value));\n        } else {\n          target = function target() {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            return value.apply(this, args);\n          };\n\n          target.prototype = Hoek.clone(value.prototype);\n        }\n\n        var valueKeys = Object.keys(value);\n\n        for (var i = 0; i < valueKeys.length; ++i) {\n          target[valueKeys[i]] = value[valueKeys[i]];\n        }\n      } else {\n        target = value;\n      } // Rename keys\n\n\n      var renamed = {};\n\n      for (var _i = 0; _i < this._inner.renames.length; ++_i) {\n        var rename = this._inner.renames[_i];\n\n        if (rename.isRegExp) {\n          var targetKeys = Object.keys(target);\n          var matchedTargetKeys = [];\n\n          for (var j = 0; j < targetKeys.length; ++j) {\n            if (rename.from.test(targetKeys[j])) {\n              matchedTargetKeys.push(targetKeys[j]);\n            }\n          }\n\n          var allUndefined = matchedTargetKeys.every(function (key) {\n            return target[key] === undefined;\n          });\n\n          if (rename.options.ignoreUndefined && allUndefined) {\n            continue;\n          }\n\n          if (!rename.options.multiple && renamed[rename.to]) {\n            errors.push(this.createError('object.rename.regex.multiple', {\n              from: matchedTargetKeys,\n              to: rename.to\n            }, state, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          }\n\n          if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n            errors.push(this.createError('object.rename.regex.override', {\n              from: matchedTargetKeys,\n              to: rename.to\n            }, state, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          }\n\n          if (allUndefined) {\n            delete target[rename.to];\n          } else {\n            target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\n          }\n\n          renamed[rename.to] = true;\n\n          if (!rename.options.alias) {\n            for (var _j = 0; _j < matchedTargetKeys.length; ++_j) {\n              delete target[matchedTargetKeys[_j]];\n            }\n          }\n        } else {\n          if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n            continue;\n          }\n\n          if (!rename.options.multiple && renamed[rename.to]) {\n            errors.push(this.createError('object.rename.multiple', {\n              from: rename.from,\n              to: rename.to\n            }, state, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          }\n\n          if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n            errors.push(this.createError('object.rename.override', {\n              from: rename.from,\n              to: rename.to\n            }, state, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          }\n\n          if (target[rename.from] === undefined) {\n            delete target[rename.to];\n          } else {\n            target[rename.to] = target[rename.from];\n          }\n\n          renamed[rename.to] = true;\n\n          if (!rename.options.alias) {\n            delete target[rename.from];\n          }\n        }\n      } // Validate schema\n\n\n      if (!this._inner.children && // null allows any keys\n      !this._inner.patterns.length && !this._inner.dependencies.length) {\n        return finish();\n      }\n\n      var unprocessed = new Set(Object.keys(target));\n\n      if (this._inner.children) {\n        var stripProps = [];\n\n        for (var _i2 = 0; _i2 < this._inner.children.length; ++_i2) {\n          var child = this._inner.children[_i2];\n          var key = child.key;\n          var item = target[key];\n          unprocessed.delete(key);\n          var localState = new State(key, [].concat(_toConsumableArray(state.path), [key]), target, state.reference);\n\n          var result = child.schema._validate(item, localState, options);\n\n          if (result.errors) {\n            errors.push(this.createError('object.child', {\n              key: key,\n              child: child.schema._getLabel(key),\n              reason: result.errors\n            }, localState, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          } else {\n            if (child.schema._flags.strip || result.value === undefined && result.value !== item) {\n              stripProps.push(key);\n              target[key] = result.finalValue;\n            } else if (result.value !== undefined) {\n              target[key] = result.value;\n            }\n          }\n        }\n\n        for (var _i3 = 0; _i3 < stripProps.length; ++_i3) {\n          delete target[stripProps[_i3]];\n        }\n      } // Unknown keys\n\n\n      if (unprocessed.size && this._inner.patterns.length) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = unprocessed[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _key2 = _step.value;\n\n            var _localState = new State(_key2, [].concat(_toConsumableArray(state.path), [_key2]), target, state.reference);\n\n            var _item = target[_key2];\n\n            for (var _i4 = 0; _i4 < this._inner.patterns.length; ++_i4) {\n              var pattern = this._inner.patterns[_i4];\n\n              if (pattern.regex ? pattern.regex.test(_key2) : !pattern.schema.validate(_key2).error) {\n                unprocessed.delete(_key2);\n\n                var _result = pattern.rule._validate(_item, _localState, options);\n\n                if (_result.errors) {\n                  errors.push(this.createError('object.child', {\n                    key: _key2,\n                    child: pattern.rule._getLabel(_key2),\n                    reason: _result.errors\n                  }, _localState, options));\n\n                  if (options.abortEarly) {\n                    return finish();\n                  }\n                }\n\n                target[_key2] = _result.value;\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\n        if (options.stripUnknown && this._flags.allowUnknown !== true || options.skipFunctions) {\n          var stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.objects : false;\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = unprocessed[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var _key3 = _step2.value;\n\n              if (stripUnknown) {\n                delete target[_key3];\n                unprocessed.delete(_key3);\n              } else if (typeof target[_key3] === 'function') {\n                unprocessed.delete(_key3);\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n\n        if (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown) {\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = unprocessed[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var unprocessedKey = _step3.value;\n              errors.push(this.createError('object.allowUnknown', {\n                child: unprocessedKey,\n                value: target[unprocessedKey]\n              }, {\n                key: unprocessedKey,\n                path: [].concat(_toConsumableArray(state.path), [unprocessedKey])\n              }, options, {}));\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } // Validate dependencies\n\n\n      for (var _i5 = 0; _i5 < this._inner.dependencies.length; ++_i5) {\n        var dep = this._inner.dependencies[_i5];\n        var hasKey = dep.key !== null;\n        var splitKey = hasKey && dep.key.split('.');\n\n        var _localState2 = hasKey ? new State(splitKey[splitKey.length - 1], [].concat(_toConsumableArray(state.path), _toConsumableArray(splitKey))) : new State(null, state.path);\n\n        var err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key, {\n          functions: true\n        }), dep.peers, target, _localState2, options);\n\n        if (err instanceof Errors.Err) {\n          errors.push(err);\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n      }\n\n      return finish();\n    }\n  }, {\n    key: \"keys\",\n    value: function keys(schema) {\n      Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n      Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n      var obj = this.clone();\n\n      if (!schema) {\n        obj._inner.children = null;\n        return obj;\n      }\n\n      var children = Object.keys(schema);\n\n      if (!children.length) {\n        obj._inner.children = [];\n        return obj;\n      }\n\n      var topo = new Topo();\n\n      if (obj._inner.children) {\n        for (var i = 0; i < obj._inner.children.length; ++i) {\n          var child = obj._inner.children[i]; // Only add the key if we are not going to replace it later\n\n          if (!children.includes(child.key)) {\n            topo.add(child, {\n              after: child._refs,\n              group: child.key\n            });\n          }\n        }\n      }\n\n      for (var _i6 = 0; _i6 < children.length; ++_i6) {\n        var key = children[_i6];\n        var _child = schema[key];\n\n        try {\n          var cast = Cast.schema(this._currentJoi, _child);\n          topo.add({\n            key: key,\n            schema: cast\n          }, {\n            after: cast._refs,\n            group: key\n          });\n        } catch (castErr) {\n          if (castErr.hasOwnProperty('path')) {\n            castErr.path = key + '.' + castErr.path;\n          } else {\n            castErr.path = key;\n          }\n\n          throw castErr;\n        }\n      }\n\n      obj._inner.children = topo.nodes;\n      return obj;\n    }\n  }, {\n    key: \"append\",\n    value: function append(schema) {\n      // Skip any changes\n      if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n        return this;\n      }\n\n      return this.keys(schema);\n    }\n  }, {\n    key: \"unknown\",\n    value: function unknown(allow) {\n      var value = allow !== false;\n\n      if (this._flags.allowUnknown === value) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.allowUnknown = value;\n      return obj;\n    }\n  }, {\n    key: \"length\",\n    value: function length(limit) {\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n      return this._test('length', limit, function (value, state, options) {\n        if (Object.keys(value).length === limit) {\n          return value;\n        }\n\n        return this.createError('object.length', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"min\",\n    value: function min(limit) {\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n      return this._test('min', limit, function (value, state, options) {\n        if (Object.keys(value).length >= limit) {\n          return value;\n        }\n\n        return this.createError('object.min', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"max\",\n    value: function max(limit) {\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n      return this._test('max', limit, function (value, state, options) {\n        if (Object.keys(value).length <= limit) {\n          return value;\n        }\n\n        return this.createError('object.max', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"pattern\",\n    value: function pattern(_pattern, schema) {\n      var isRegExp = _pattern instanceof RegExp;\n      Hoek.assert(isRegExp || _pattern instanceof Any, 'pattern must be a regex or schema');\n      Hoek.assert(schema !== undefined, 'Invalid rule');\n\n      if (isRegExp) {\n        Hoek.assert(!_pattern.flags.includes('g') && !_pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n      }\n\n      try {\n        schema = Cast.schema(this._currentJoi, schema);\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n        }\n\n        throw castErr;\n      }\n\n      var obj = this.clone();\n\n      if (isRegExp) {\n        obj._inner.patterns.push({\n          regex: _pattern,\n          rule: schema\n        });\n      } else {\n        obj._inner.patterns.push({\n          schema: _pattern,\n          rule: schema\n        });\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"schema\",\n    value: function schema() {\n      return this._test('schema', null, function (value, state, options) {\n        if (value instanceof Any) {\n          return value;\n        }\n\n        return this.createError('object.schema', null, state, options);\n      });\n    }\n  }, {\n    key: \"with\",\n    value: function _with(key, peers) {\n      Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n      return this._dependency('with', key, peers);\n    }\n  }, {\n    key: \"without\",\n    value: function without(key, peers) {\n      Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n      return this._dependency('without', key, peers);\n    }\n  }, {\n    key: \"xor\",\n    value: function xor() {\n      for (var _len2 = arguments.length, peers = new Array(_len2), _key4 = 0; _key4 < _len2; _key4++) {\n        peers[_key4] = arguments[_key4];\n      }\n\n      peers = Hoek.flatten(peers);\n      return this._dependency('xor', null, peers);\n    }\n  }, {\n    key: \"oxor\",\n    value: function oxor() {\n      for (var _len3 = arguments.length, peers = new Array(_len3), _key5 = 0; _key5 < _len3; _key5++) {\n        peers[_key5] = arguments[_key5];\n      }\n\n      return this._dependency('oxor', null, peers);\n    }\n  }, {\n    key: \"or\",\n    value: function or() {\n      for (var _len4 = arguments.length, peers = new Array(_len4), _key6 = 0; _key6 < _len4; _key6++) {\n        peers[_key6] = arguments[_key6];\n      }\n\n      peers = Hoek.flatten(peers);\n      return this._dependency('or', null, peers);\n    }\n  }, {\n    key: \"and\",\n    value: function and() {\n      for (var _len5 = arguments.length, peers = new Array(_len5), _key7 = 0; _key7 < _len5; _key7++) {\n        peers[_key7] = arguments[_key7];\n      }\n\n      peers = Hoek.flatten(peers);\n      return this._dependency('and', null, peers);\n    }\n  }, {\n    key: \"nand\",\n    value: function nand() {\n      for (var _len6 = arguments.length, peers = new Array(_len6), _key8 = 0; _key8 < _len6; _key8++) {\n        peers[_key8] = arguments[_key8];\n      }\n\n      peers = Hoek.flatten(peers);\n      return this._dependency('nand', null, peers);\n    }\n  }, {\n    key: \"requiredKeys\",\n    value: function requiredKeys() {\n      for (var _len7 = arguments.length, children = new Array(_len7), _key9 = 0; _key9 < _len7; _key9++) {\n        children[_key9] = arguments[_key9];\n      }\n\n      children = Hoek.flatten(children);\n      return this.applyFunctionToChildren(children, 'required');\n    }\n  }, {\n    key: \"optionalKeys\",\n    value: function optionalKeys() {\n      for (var _len8 = arguments.length, children = new Array(_len8), _key10 = 0; _key10 < _len8; _key10++) {\n        children[_key10] = arguments[_key10];\n      }\n\n      children = Hoek.flatten(children);\n      return this.applyFunctionToChildren(children, 'optional');\n    }\n  }, {\n    key: \"forbiddenKeys\",\n    value: function forbiddenKeys() {\n      for (var _len9 = arguments.length, children = new Array(_len9), _key11 = 0; _key11 < _len9; _key11++) {\n        children[_key11] = arguments[_key11];\n      }\n\n      children = Hoek.flatten(children);\n      return this.applyFunctionToChildren(children, 'forbidden');\n    }\n  }, {\n    key: \"rename\",\n    value: function rename(from, to, options) {\n      Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n      Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n      Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n      for (var i = 0; i < this._inner.renames.length; ++i) {\n        Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n      }\n\n      var obj = this.clone();\n\n      obj._inner.renames.push({\n        from: from,\n        to: to,\n        options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\n        isRegExp: from instanceof RegExp\n      });\n\n      return obj;\n    }\n  }, {\n    key: \"applyFunctionToChildren\",\n    value: function applyFunctionToChildren(children, fn) {\n      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var root = arguments.length > 3 ? arguments[3] : undefined;\n      children = [].concat(children);\n      Hoek.assert(children.length > 0, 'expected at least one children');\n      var groupedChildren = internals.groupChildren(children);\n      var obj;\n\n      if ('' in groupedChildren) {\n        obj = this[fn].apply(this, _toConsumableArray(args));\n        delete groupedChildren[''];\n      } else {\n        obj = this.clone();\n      }\n\n      if (obj._inner.children) {\n        root = root ? root + '.' : '';\n\n        for (var i = 0; i < obj._inner.children.length; ++i) {\n          var child = obj._inner.children[i];\n          var group = groupedChildren[child.key];\n\n          if (group) {\n            obj._inner.children[i] = {\n              key: child.key,\n              _refs: child._refs,\n              schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n            };\n            delete groupedChildren[child.key];\n          }\n        }\n      }\n\n      var remaining = Object.keys(groupedChildren);\n      Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n      return obj;\n    }\n  }, {\n    key: \"_dependency\",\n    value: function _dependency(type, key, peers) {\n      peers = [].concat(peers);\n\n      for (var i = 0; i < peers.length; ++i) {\n        Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n      }\n\n      var obj = this.clone();\n\n      obj._inner.dependencies.push({\n        type: type,\n        key: key,\n        peers: peers\n      });\n\n      return obj;\n    }\n  }, {\n    key: \"describe\",\n    value: function describe(shallow) {\n      var description = _get(_getPrototypeOf(_class.prototype), \"describe\", this).call(this);\n\n      if (description.rules) {\n        for (var i = 0; i < description.rules.length; ++i) {\n          var rule = description.rules[i]; // Coverage off for future-proof descriptions, only object().assert() is use right now\n\n          if (\n          /* $lab:coverage:off$ */\n          rule.arg && typeof rule.arg === 'object' && rule.arg.schema && rule.arg.ref\n          /* $lab:coverage:on$ */\n          ) {\n              rule.arg = {\n                schema: rule.arg.schema.describe(),\n                ref: rule.arg.ref.toString()\n              };\n            }\n        }\n      }\n\n      if (this._inner.children && !shallow) {\n        description.children = {};\n\n        for (var _i7 = 0; _i7 < this._inner.children.length; ++_i7) {\n          var child = this._inner.children[_i7];\n          description.children[child.key] = child.schema.describe();\n        }\n      }\n\n      if (this._inner.dependencies.length) {\n        description.dependencies = Hoek.clone(this._inner.dependencies);\n      }\n\n      if (this._inner.patterns.length) {\n        description.patterns = [];\n\n        for (var _i8 = 0; _i8 < this._inner.patterns.length; ++_i8) {\n          var pattern = this._inner.patterns[_i8];\n\n          if (pattern.regex) {\n            description.patterns.push({\n              regex: pattern.regex.toString(),\n              rule: pattern.rule.describe()\n            });\n          } else {\n            description.patterns.push({\n              schema: pattern.schema.describe(),\n              rule: pattern.rule.describe()\n            });\n          }\n        }\n      }\n\n      if (this._inner.renames.length > 0) {\n        description.renames = Hoek.clone(this._inner.renames);\n      }\n\n      return description;\n    }\n  }, {\n    key: \"assert\",\n    value: function assert(ref, schema, message) {\n      ref = Cast.ref(ref);\n      Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n      message = message || 'pass the assertion test';\n      Hoek.assert(typeof message === 'string', 'Message must be a string');\n\n      try {\n        schema = Cast.schema(this._currentJoi, schema);\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n        }\n\n        throw castErr;\n      }\n\n      var key = ref.path[ref.path.length - 1];\n      var path = ref.path.join('.');\n      return this._test('assert', {\n        schema: schema,\n        ref: ref\n      }, function (value, state, options) {\n        var result = schema._validate(ref(value), null, options, value);\n\n        if (!result.errors) {\n          return value;\n        }\n\n        var localState = new State(key, ref.path, state.parent, state.reference);\n        return this.createError('object.assert', {\n          ref: path,\n          message: message\n        }, localState, options);\n      });\n    }\n  }, {\n    key: \"type\",\n    value: function type(constructor) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constructor.name;\n      Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n      var typeData = {\n        name: name,\n        ctor: constructor\n      };\n      return this._test('type', typeData, function (value, state, options) {\n        if (value instanceof constructor) {\n          return value;\n        }\n\n        return this.createError('object.type', {\n          type: typeData.name,\n          value: value\n        }, state, options);\n      });\n    }\n  }]);\n\n  return _class;\n}(Any);\n\ninternals.safeParse = function (value) {\n  try {\n    return JSON.parse(value);\n  } catch (parseErr) {}\n\n  return value;\n};\n\ninternals.renameDefaults = {\n  alias: false,\n  // Keep old value in place\n  multiple: false,\n  // Allow renaming multiple keys into the same target\n  override: false // Overrides an existing key\n\n};\n\ninternals.groupChildren = function (children) {\n  children.sort();\n  var grouped = {};\n\n  for (var i = 0; i < children.length; ++i) {\n    var child = children[i];\n    Hoek.assert(typeof child === 'string', 'children must be strings');\n    var group = child.split('.')[0];\n    var childGroup = grouped[group] = grouped[group] || [];\n    childGroup.push(child.substring(group.length + 1));\n  }\n\n  return grouped;\n};\n\ninternals.keysToLabels = function (schema, keys) {\n  var children = schema._inner.children;\n\n  if (!children) {\n    return keys;\n  }\n\n  var findLabel = function findLabel(key) {\n    var matchingChild = schema._currentJoi.reach(schema, key);\n\n    return matchingChild ? matchingChild._getLabel(key) : key;\n  };\n\n  if (Array.isArray(keys)) {\n    return keys.map(findLabel);\n  }\n\n  return findLabel(keys);\n};\n\ninternals.with = function (key, value, peers, parent, state, options) {\n  if (value === undefined) {\n    return;\n  }\n\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n    var keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist === undefined) {\n      return this.createError('object.with', {\n        main: key,\n        mainWithLabel: internals.keysToLabels(this, key),\n        peer: peer,\n        peerWithLabel: internals.keysToLabels(this, peer)\n      }, state, options);\n    }\n  }\n};\n\ninternals.without = function (key, value, peers, parent, state, options) {\n  if (value === undefined) {\n    return;\n  }\n\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n    var keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      return this.createError('object.without', {\n        main: key,\n        mainWithLabel: internals.keysToLabels(this, key),\n        peer: peer,\n        peerWithLabel: internals.keysToLabels(this, peer)\n      }, state, options);\n    }\n  }\n};\n\ninternals.xor = function (key, value, peers, parent, state, options) {\n  var present = [];\n\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n    var keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  if (present.length === 1) {\n    return;\n  }\n\n  var context = {\n    peers: peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  };\n\n  if (present.length === 0) {\n    return this.createError('object.missing', context, state, options);\n  }\n\n  context.present = present;\n  context.presentWithLabels = internals.keysToLabels(this, present);\n  return this.createError('object.xor', context, state, options);\n};\n\ninternals.oxor = function (key, value, peers, parent, state, options) {\n  var present = [];\n\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n    var keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  if (!present.length || present.length === 1) {\n    return;\n  }\n\n  var context = {\n    peers: peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  };\n  context.present = present;\n  context.presentWithLabels = internals.keysToLabels(this, present);\n  return this.createError('object.oxor', context, state, options);\n};\n\ninternals.or = function (key, value, peers, parent, state, options) {\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n    var keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      return;\n    }\n  }\n\n  return this.createError('object.missing', {\n    peers: peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  }, state, options);\n};\n\ninternals.and = function (key, value, peers, parent, state, options) {\n  var missing = [];\n  var present = [];\n  var count = peers.length;\n\n  for (var i = 0; i < count; ++i) {\n    var peer = peers[i];\n    var keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist === undefined) {\n      missing.push(peer);\n    } else {\n      present.push(peer);\n    }\n  }\n\n  var aon = missing.length === count || present.length === count;\n\n  if (!aon) {\n    return this.createError('object.and', {\n      present: present,\n      presentWithLabels: internals.keysToLabels(this, present),\n      missing: missing,\n      missingWithLabels: internals.keysToLabels(this, missing)\n    }, state, options);\n  }\n};\n\ninternals.nand = function (key, value, peers, parent, state, options) {\n  var present = [];\n\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n    var keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  var main = peers[0];\n  var values = peers.slice(1);\n  var allPresent = present.length === peers.length;\n  return allPresent ? this.createError('object.nand', {\n    main: main,\n    mainWithLabel: internals.keysToLabels(this, main),\n    peers: values,\n    peersWithLabels: internals.keysToLabels(this, values)\n  }, state, options) : null;\n};\n\nmodule.exports = new internals.Object();","map":{"version":3,"sources":["/home/coeus/Desktop/React/movie-list/node_modules/joi/lib/types/object/index.js"],"names":["Hoek","require","Topo","Any","Errors","Cast","State","internals","Object","_type","_inner","children","renames","dependencies","patterns","length","keys","value","state","options","target","errors","finish","convert","safeParse","type","_flags","func","Array","isArray","push","createError","create","getPrototypeOf","args","apply","prototype","clone","valueKeys","i","renamed","rename","isRegExp","targetKeys","matchedTargetKeys","j","from","test","allUndefined","every","key","undefined","ignoreUndefined","multiple","to","abortEarly","hasOwnProperty","call","override","alias","unprocessed","Set","stripProps","child","item","delete","localState","path","reference","result","schema","_validate","_getLabel","reason","strip","finalValue","size","pattern","regex","validate","error","rule","stripUnknown","allowUnknown","skipFunctions","objects","unprocessedKey","dep","hasKey","splitKey","split","err","reach","functions","peers","Err","assert","obj","topo","includes","add","after","_refs","group","cast","_currentJoi","castErr","nodes","allow","limit","Number","isSafeInteger","_test","RegExp","flags","message","arguments","_dependency","flatten","applyFunctionToChildren","applyToDefaults","renameDefaults","fn","root","concat","groupedChildren","groupChildren","remaining","join","shallow","description","rules","arg","ref","describe","toString","isContext","depth","parent","constructor","name","typeData","ctor","JSON","parse","parseErr","sort","grouped","childGroup","substring","keysToLabels","findLabel","matchingChild","map","with","peer","keysExist","main","mainWithLabel","peerWithLabel","without","xor","present","context","peersWithLabels","presentWithLabels","oxor","or","and","missing","count","aon","missingWithLabels","nand","values","slice","allPresent","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Topo = require('topo');\nconst Any = require('../any');\nconst Errors = require('../../errors');\nconst Cast = require('../../cast');\nconst State = require('../state');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Object = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'object';\n        this._inner.children = null;\n        this._inner.renames = [];\n        this._inner.dependencies = [];\n        this._inner.patterns = [];\n    }\n\n    _init(...args) {\n\n        return args.length ? this.keys(...args) : this;\n    }\n\n    _base(value, state, options) {\n\n        let target = value;\n        const errors = [];\n        const finish = () => {\n\n            return {\n                value: target,\n                errors: errors.length ? errors : null\n            };\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            value = internals.safeParse(value);\n        }\n\n        const type = this._flags.func ? 'function' : 'object';\n        if (!value ||\n            typeof value !== type ||\n            Array.isArray(value)) {\n\n            errors.push(this.createError(type + '.base', { value }, state, options));\n            return finish();\n        }\n\n        // Skip if there are no other rules to test\n\n        if (!this._inner.renames.length &&\n            !this._inner.dependencies.length &&\n            !this._inner.children &&                    // null allows any keys\n            !this._inner.patterns.length) {\n\n            target = value;\n            return finish();\n        }\n\n        // Ensure target is a local copy (parsed) or shallow copy\n\n        if (target === value) {\n            if (type === 'object') {\n                target = Object.create(Object.getPrototypeOf(value));\n            }\n            else {\n                target = function (...args) {\n\n                    return value.apply(this, args);\n                };\n\n                target.prototype = Hoek.clone(value.prototype);\n            }\n\n            const valueKeys = Object.keys(value);\n            for (let i = 0; i < valueKeys.length; ++i) {\n                target[valueKeys[i]] = value[valueKeys[i]];\n            }\n        }\n        else {\n            target = value;\n        }\n\n        // Rename keys\n\n        const renamed = {};\n        for (let i = 0; i < this._inner.renames.length; ++i) {\n            const rename = this._inner.renames[i];\n\n            if (rename.isRegExp) {\n                const targetKeys = Object.keys(target);\n                const matchedTargetKeys = [];\n\n                for (let j = 0; j < targetKeys.length; ++j) {\n                    if (rename.from.test(targetKeys[j])) {\n                        matchedTargetKeys.push(targetKeys[j]);\n                    }\n                }\n\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\n                if (rename.options.ignoreUndefined && allUndefined) {\n                    continue;\n                }\n\n                if (!rename.options.multiple &&\n                    renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\n                    !rename.options.override &&\n                    !renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (allUndefined) {\n                    delete target[rename.to];\n                }\n                else {\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\n                }\n\n                renamed[rename.to] = true;\n\n                if (!rename.options.alias) {\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\n                        delete target[matchedTargetKeys[j]];\n                    }\n                }\n            }\n            else {\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n                    continue;\n                }\n\n                if (!rename.options.multiple &&\n                    renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\n                    !rename.options.override &&\n                    !renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (target[rename.from] === undefined) {\n                    delete target[rename.to];\n                }\n                else {\n                    target[rename.to] = target[rename.from];\n                }\n\n                renamed[rename.to] = true;\n\n                if (!rename.options.alias) {\n                    delete target[rename.from];\n                }\n            }\n        }\n\n        // Validate schema\n\n        if (!this._inner.children &&            // null allows any keys\n            !this._inner.patterns.length &&\n            !this._inner.dependencies.length) {\n\n            return finish();\n        }\n\n        const unprocessed = new Set(Object.keys(target));\n\n        if (this._inner.children) {\n            const stripProps = [];\n\n            for (let i = 0; i < this._inner.children.length; ++i) {\n                const child = this._inner.children[i];\n                const key = child.key;\n                const item = target[key];\n\n                unprocessed.delete(key);\n\n                const localState = new State(key, [...state.path, key], target, state.reference);\n                const result = child.schema._validate(item, localState, options);\n                if (result.errors) {\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\n\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n                else {\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\n                        stripProps.push(key);\n                        target[key] = result.finalValue;\n                    }\n                    else if (result.value !== undefined) {\n                        target[key] = result.value;\n                    }\n                }\n            }\n\n            for (let i = 0; i < stripProps.length; ++i) {\n                delete target[stripProps[i]];\n            }\n        }\n\n        // Unknown keys\n\n        if (unprocessed.size && this._inner.patterns.length) {\n\n            for (const key of unprocessed) {\n                const localState = new State(key, [...state.path, key], target, state.reference);\n                const item = target[key];\n\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\n                    const pattern = this._inner.patterns[i];\n\n                    if (pattern.regex ?\n                        pattern.regex.test(key) :\n                        !pattern.schema.validate(key).error) {\n\n                        unprocessed.delete(key);\n\n                        const result = pattern.rule._validate(item, localState, options);\n                        if (result.errors) {\n                            errors.push(this.createError('object.child', {\n                                key,\n                                child: pattern.rule._getLabel(key),\n                                reason: result.errors\n                            }, localState, options));\n\n                            if (options.abortEarly) {\n                                return finish();\n                            }\n                        }\n\n                        target[key] = result.value;\n                    }\n                }\n            }\n        }\n\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\n                options.skipFunctions) {\n\n                const stripUnknown = options.stripUnknown\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\n                    : false;\n\n\n                for (const key of unprocessed) {\n                    if (stripUnknown) {\n                        delete target[key];\n                        unprocessed.delete(key);\n                    }\n                    else if (typeof target[key] === 'function') {\n                        unprocessed.delete(key);\n                    }\n                }\n            }\n\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\n\n                for (const unprocessedKey of unprocessed) {\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\n                        key: unprocessedKey,\n                        path: [...state.path, unprocessedKey]\n                    }, options, {}));\n                }\n            }\n        }\n\n        // Validate dependencies\n\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\n            const dep = this._inner.dependencies[i];\n            const hasKey = dep.key !== null;\n            const splitKey = hasKey && dep.key.split('.');\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key, { functions: true }), dep.peers, target, localState, options);\n            if (err instanceof Errors.Err) {\n                errors.push(err);\n                if (options.abortEarly) {\n                    return finish();\n                }\n            }\n        }\n\n        return finish();\n    }\n\n    keys(schema) {\n\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n\n        const obj = this.clone();\n\n        if (!schema) {\n            obj._inner.children = null;\n            return obj;\n        }\n\n        const children = Object.keys(schema);\n\n        if (!children.length) {\n            obj._inner.children = [];\n            return obj;\n        }\n\n        const topo = new Topo();\n        if (obj._inner.children) {\n            for (let i = 0; i < obj._inner.children.length; ++i) {\n                const child = obj._inner.children[i];\n\n                // Only add the key if we are not going to replace it later\n                if (!children.includes(child.key)) {\n                    topo.add(child, { after: child._refs, group: child.key });\n                }\n            }\n        }\n\n        for (let i = 0; i < children.length; ++i) {\n            const key = children[i];\n            const child = schema[key];\n            try {\n                const cast = Cast.schema(this._currentJoi, child);\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = key + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = key;\n                }\n\n                throw castErr;\n            }\n        }\n\n        obj._inner.children = topo.nodes;\n\n        return obj;\n    }\n\n    append(schema) {\n        // Skip any changes\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n            return this;\n        }\n\n        return this.keys(schema);\n    }\n\n    unknown(allow) {\n\n        const value = allow !== false;\n\n        if (this._flags.allowUnknown === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.allowUnknown = value;\n        return obj;\n    }\n\n    length(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('length', limit, function (value, state, options) {\n\n            if (Object.keys(value).length === limit) {\n                return value;\n            }\n\n            return this.createError('object.length', { limit, value }, state, options);\n        });\n    }\n\n    min(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('min', limit, function (value, state, options) {\n\n            if (Object.keys(value).length >= limit) {\n                return value;\n            }\n\n            return this.createError('object.min', { limit, value }, state, options);\n        });\n    }\n\n    max(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('max', limit, function (value, state, options) {\n\n            if (Object.keys(value).length <= limit) {\n                return value;\n            }\n\n            return this.createError('object.max', { limit, value }, state, options);\n        });\n    }\n\n    pattern(pattern, schema) {\n\n        const isRegExp = pattern instanceof RegExp;\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\n        Hoek.assert(schema !== undefined, 'Invalid rule');\n\n        if (isRegExp) {\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n        }\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = `${castErr.message}(${castErr.path})`;\n            }\n\n            throw castErr;\n        }\n\n        const obj = this.clone();\n        if (isRegExp) {\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\n        }\n        else {\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\n        }\n\n        return obj;\n    }\n\n    schema() {\n\n        return this._test('schema', null, function (value, state, options) {\n\n            if (value instanceof Any) {\n                return value;\n            }\n\n            return this.createError('object.schema', null, state, options);\n        });\n    }\n\n    with(key, peers) {\n\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n\n        return this._dependency('with', key, peers);\n    }\n\n    without(key, peers) {\n\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n\n        return this._dependency('without', key, peers);\n    }\n\n    xor(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('xor', null, peers);\n    }\n\n    oxor(...peers) {\n\n        return this._dependency('oxor', null, peers);\n    }\n\n    or(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('or', null, peers);\n    }\n\n    and(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('and', null, peers);\n    }\n\n    nand(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('nand', null, peers);\n    }\n\n    requiredKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'required');\n    }\n\n    optionalKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'optional');\n    }\n\n    forbiddenKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'forbidden');\n    }\n\n    rename(from, to, options) {\n\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n        for (let i = 0; i < this._inner.renames.length; ++i) {\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n        }\n\n        const obj = this.clone();\n\n        obj._inner.renames.push({\n            from,\n            to,\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\n            isRegExp: from instanceof RegExp\n        });\n\n        return obj;\n    }\n\n    applyFunctionToChildren(children, fn, args = [], root) {\n\n        children = [].concat(children);\n        Hoek.assert(children.length > 0, 'expected at least one children');\n\n        const groupedChildren = internals.groupChildren(children);\n        let obj;\n\n        if ('' in groupedChildren) {\n            obj = this[fn](...args);\n            delete groupedChildren[''];\n        }\n        else {\n            obj = this.clone();\n        }\n\n        if (obj._inner.children) {\n            root = root ? (root + '.') : '';\n\n            for (let i = 0; i < obj._inner.children.length; ++i) {\n                const child = obj._inner.children[i];\n                const group = groupedChildren[child.key];\n\n                if (group) {\n                    obj._inner.children[i] = {\n                        key: child.key,\n                        _refs: child._refs,\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n                    };\n\n                    delete groupedChildren[child.key];\n                }\n            }\n        }\n\n        const remaining = Object.keys(groupedChildren);\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n\n        return obj;\n    }\n\n    _dependency(type, key, peers) {\n\n        peers = [].concat(peers);\n        for (let i = 0; i < peers.length; ++i) {\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n        }\n\n        const obj = this.clone();\n        obj._inner.dependencies.push({ type, key, peers });\n        return obj;\n    }\n\n    describe(shallow) {\n\n        const description = super.describe();\n\n        if (description.rules) {\n            for (let i = 0; i < description.rules.length; ++i) {\n                const rule = description.rules[i];\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\n                if (/* $lab:coverage:off$ */rule.arg &&\n                    typeof rule.arg === 'object' &&\n                    rule.arg.schema &&\n                    rule.arg.ref /* $lab:coverage:on$ */) {\n                    rule.arg = {\n                        schema: rule.arg.schema.describe(),\n                        ref: rule.arg.ref.toString()\n                    };\n                }\n            }\n        }\n\n        if (this._inner.children &&\n            !shallow) {\n\n            description.children = {};\n            for (let i = 0; i < this._inner.children.length; ++i) {\n                const child = this._inner.children[i];\n                description.children[child.key] = child.schema.describe();\n            }\n        }\n\n        if (this._inner.dependencies.length) {\n            description.dependencies = Hoek.clone(this._inner.dependencies);\n        }\n\n        if (this._inner.patterns.length) {\n            description.patterns = [];\n\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\n                const pattern = this._inner.patterns[i];\n                if (pattern.regex) {\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\n                }\n                else {\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\n                }\n            }\n        }\n\n        if (this._inner.renames.length > 0) {\n            description.renames = Hoek.clone(this._inner.renames);\n        }\n\n        return description;\n    }\n\n    assert(ref, schema, message) {\n\n        ref = Cast.ref(ref);\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n        message = message || 'pass the assertion test';\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = `${castErr.message}(${castErr.path})`;\n            }\n\n            throw castErr;\n        }\n\n        const key = ref.path[ref.path.length - 1];\n        const path = ref.path.join('.');\n\n        return this._test('assert', { schema, ref }, function (value, state, options) {\n\n            const result = schema._validate(ref(value), null, options, value);\n            if (!result.errors) {\n                return value;\n            }\n\n            const localState = new State(key, ref.path, state.parent, state.reference);\n            return this.createError('object.assert', { ref: path, message }, localState, options);\n        });\n    }\n\n    type(constructor, name = constructor.name) {\n\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n        const typeData = {\n            name,\n            ctor: constructor\n        };\n\n        return this._test('type', typeData, function (value, state, options) {\n\n            if (value instanceof constructor) {\n                return value;\n            }\n\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\n        });\n    }\n};\n\ninternals.safeParse = function (value) {\n\n    try {\n        return JSON.parse(value);\n    }\n    catch (parseErr) {}\n\n    return value;\n};\n\n\ninternals.renameDefaults = {\n    alias: false,                   // Keep old value in place\n    multiple: false,                // Allow renaming multiple keys into the same target\n    override: false                 // Overrides an existing key\n};\n\n\ninternals.groupChildren = function (children) {\n\n    children.sort();\n\n    const grouped = {};\n\n    for (let i = 0; i < children.length; ++i) {\n        const child = children[i];\n        Hoek.assert(typeof child === 'string', 'children must be strings');\n        const group = child.split('.')[0];\n        const childGroup = grouped[group] = (grouped[group] || []);\n        childGroup.push(child.substring(group.length + 1));\n    }\n\n    return grouped;\n};\n\n\ninternals.keysToLabels = function (schema, keys) {\n\n    const children = schema._inner.children;\n\n    if (!children) {\n        return keys;\n    }\n\n    const findLabel = function (key) {\n\n        const matchingChild = schema._currentJoi.reach(schema, key);\n        return matchingChild ? matchingChild._getLabel(key) : key;\n    };\n\n    if (Array.isArray(keys)) {\n        return keys.map(findLabel);\n    }\n\n    return findLabel(keys);\n};\n\n\ninternals.with = function (key, value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist === undefined) {\n\n            return this.createError('object.with', {\n                main: key,\n                mainWithLabel: internals.keysToLabels(this, key),\n                peer,\n                peerWithLabel: internals.keysToLabels(this, peer)\n            }, state, options);\n        }\n    }\n};\n\n\ninternals.without = function (key, value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n\n            return this.createError('object.without', {\n                main: key,\n                mainWithLabel: internals.keysToLabels(this, key),\n                peer,\n                peerWithLabel: internals.keysToLabels(this, peer)\n            }, state, options);\n        }\n    }\n};\n\n\ninternals.xor = function (key, value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n            present.push(peer);\n        }\n    }\n\n    if (present.length === 1) {\n        return;\n    }\n\n    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };\n\n    if (present.length === 0) {\n        return this.createError('object.missing', context, state, options);\n    }\n\n    context.present = present;\n    context.presentWithLabels = internals.keysToLabels(this, present);\n\n    return this.createError('object.xor', context, state, options);\n};\n\n\ninternals.oxor = function (key, value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n            present.push(peer);\n        }\n    }\n\n    if (!present.length ||\n        present.length === 1) {\n\n        return;\n    }\n\n    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };\n    context.present = present;\n    context.presentWithLabels = internals.keysToLabels(this, present);\n\n    return this.createError('object.oxor', context, state, options);\n};\n\n\ninternals.or = function (key, value, peers, parent, state, options) {\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n            return;\n        }\n    }\n\n    return this.createError('object.missing', {\n        peers,\n        peersWithLabels: internals.keysToLabels(this, peers)\n    }, state, options);\n};\n\n\ninternals.and = function (key, value, peers, parent, state, options) {\n\n    const missing = [];\n    const present = [];\n    const count = peers.length;\n    for (let i = 0; i < count; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist === undefined) {\n\n            missing.push(peer);\n        }\n        else {\n            present.push(peer);\n        }\n    }\n\n    const aon = (missing.length === count || present.length === count);\n\n    if (!aon) {\n\n        return this.createError('object.and', {\n            present,\n            presentWithLabels: internals.keysToLabels(this, present),\n            missing,\n            missingWithLabels: internals.keysToLabels(this, missing)\n        }, state, options);\n    }\n};\n\n\ninternals.nand = function (key, value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n\n            present.push(peer);\n        }\n    }\n\n    const main = peers[0];\n    const values = peers.slice(1);\n    const allPresent = (present.length === peers.length);\n    return allPresent ? this.createError('object.nand', {\n        main,\n        mainWithLabel: internals.keysToLabels(this, main),\n        peers: values,\n        peersWithLabels: internals.keysToLabels(this, values)\n    }, state, options) : null;\n};\n\n\nmodule.exports = new internals.Object();\n"]},"metadata":{},"sourceType":"script"}