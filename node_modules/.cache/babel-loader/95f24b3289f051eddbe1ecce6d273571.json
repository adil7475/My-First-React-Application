{"ast":null,"code":"'use strict'; // Load modules\n\nvar _toConsumableArray = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Hoek = require('hoek');\n\nvar Settings = require('./settings');\n\nvar Ref = require('../../ref');\n\nvar Errors = require('../../errors');\n\nvar State = require('../state');\n\nvar Symbols = require('../symbols'); // Delay-loaded to prevent circular dependencies\n\n\nvar Alternatives = null;\nvar Cast = null;\nvar Schemas = null; // Declare internals\n\nvar internals = {\n  Set: require('../../set')\n};\ninternals.defaults = {\n  abortEarly: true,\n  convert: true,\n  allowUnknown: false,\n  skipFunctions: false,\n  stripUnknown: false,\n  language: {},\n  presence: 'optional',\n  strip: false,\n  noDefaults: false,\n  escapeHtml: false // context: null\n\n};\n\nmodule.exports = internals.Any = /*#__PURE__*/function () {\n  function _class() {\n    _classCallCheck(this, _class);\n\n    Cast = Cast || require('../../cast');\n    this.isJoi = true;\n    this._type = 'any';\n    this._settings = null;\n    this._valids = new internals.Set();\n    this._invalids = new internals.Set();\n    this._tests = [];\n    this._refs = [];\n    this._flags = {\n      /*\n       presence: 'optional',                   // optional, required, forbidden, ignore\n       allowOnly: false,\n       allowUnknown: undefined,\n       default: undefined,\n       forbidden: false,\n       encoding: undefined,\n       insensitive: false,\n       trim: false,\n       normalize: undefined,                   // NFC, NFD, NFKC, NFKD\n       case: undefined,                        // upper, lower\n       empty: undefined,\n       func: false,\n       raw: false\n       */\n    };\n    this._description = null;\n    this._unit = null;\n    this._notes = [];\n    this._tags = [];\n    this._examples = [];\n    this._meta = [];\n    this._inner = {}; // Hash of arrays of immutable objects\n  }\n\n  _createClass(_class, [{\n    key: \"_init\",\n    value: function _init() {\n      return this;\n    }\n  }, {\n    key: \"createError\",\n    value: function createError(type, context, state, options) {\n      var flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this._flags;\n      return Errors.create(type, context, state, options, flags);\n    }\n  }, {\n    key: \"createOverrideError\",\n    value: function createOverrideError(type, context, state, options, message, template) {\n      return Errors.create(type, context, state, options, this._flags, message, template);\n    }\n  }, {\n    key: \"checkOptions\",\n    value: function checkOptions(options) {\n      Schemas = Schemas || require('../../schemas');\n      var result = Schemas.options.validate(options);\n\n      if (result.error) {\n        throw new Error(result.error.details[0].message);\n      }\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var obj = Object.create(Object.getPrototypeOf(this));\n      obj.isJoi = true;\n      obj._currentJoi = this._currentJoi;\n      obj._type = this._type;\n      obj._settings = this._settings;\n      obj._baseType = this._baseType;\n      obj._valids = this._valids.slice();\n      obj._invalids = this._invalids.slice();\n      obj._tests = this._tests.slice();\n      obj._refs = this._refs.slice();\n      obj._flags = Hoek.clone(this._flags);\n      obj._description = this._description;\n      obj._unit = this._unit;\n      obj._notes = this._notes.slice();\n      obj._tags = this._tags.slice();\n      obj._examples = this._examples.slice();\n      obj._meta = this._meta.slice();\n      obj._inner = {};\n      var inners = Object.keys(this._inner);\n\n      for (var i = 0; i < inners.length; ++i) {\n        var key = inners[i];\n        obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(schema) {\n      var _obj$_tests, _obj$_refs, _obj$_notes, _obj$_tags, _obj$_examples, _obj$_meta;\n\n      Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\n      Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\n      var obj = this.clone();\n\n      if (this._type === 'any' && schema._type !== 'any') {\n        // Reset values as if we were \"this\"\n        var tmpObj = schema.clone();\n        var keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit', '_notes', '_tags', '_examples', '_meta', '_inner'];\n\n        for (var i = 0; i < keysToRestore.length; ++i) {\n          tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\n        }\n\n        obj = tmpObj;\n      }\n\n      obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\n\n      obj._valids.merge(schema._valids, schema._invalids);\n\n      obj._invalids.merge(schema._invalids, schema._valids);\n\n      (_obj$_tests = obj._tests).push.apply(_obj$_tests, _toConsumableArray(schema._tests));\n\n      (_obj$_refs = obj._refs).push.apply(_obj$_refs, _toConsumableArray(schema._refs));\n\n      if (obj._flags.empty && schema._flags.empty) {\n        obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\n        var flags = Object.assign({}, schema._flags);\n        delete flags.empty;\n        Hoek.merge(obj._flags, flags);\n      } else if (schema._flags.empty) {\n        obj._flags.empty = schema._flags.empty;\n\n        var _flags = Object.assign({}, schema._flags);\n\n        delete _flags.empty;\n        Hoek.merge(obj._flags, _flags);\n      } else {\n        Hoek.merge(obj._flags, schema._flags);\n      }\n\n      obj._description = schema._description || obj._description;\n      obj._unit = schema._unit || obj._unit;\n\n      (_obj$_notes = obj._notes).push.apply(_obj$_notes, _toConsumableArray(schema._notes));\n\n      (_obj$_tags = obj._tags).push.apply(_obj$_tags, _toConsumableArray(schema._tags));\n\n      (_obj$_examples = obj._examples).push.apply(_obj$_examples, _toConsumableArray(schema._examples));\n\n      (_obj$_meta = obj._meta).push.apply(_obj$_meta, _toConsumableArray(schema._meta));\n\n      var inners = Object.keys(schema._inner);\n      var isObject = obj._type === 'object';\n\n      for (var _i = 0; _i < inners.length; ++_i) {\n        var key = inners[_i];\n        var source = schema._inner[key];\n\n        if (source) {\n          var target = obj._inner[key];\n\n          if (target) {\n            if (isObject && key === 'children') {\n              var keys = {};\n\n              for (var j = 0; j < target.length; ++j) {\n                keys[target[j].key] = j;\n              }\n\n              for (var _j = 0; _j < source.length; ++_j) {\n                var sourceKey = source[_j].key;\n\n                if (keys[sourceKey] >= 0) {\n                  target[keys[sourceKey]] = {\n                    key: sourceKey,\n                    schema: target[keys[sourceKey]].schema.concat(source[_j].schema)\n                  };\n                } else {\n                  target.push(source[_j]);\n                }\n              }\n            } else {\n              obj._inner[key] = obj._inner[key].concat(source);\n            }\n          } else {\n            obj._inner[key] = source.slice();\n          }\n        }\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"_test\",\n    value: function _test(name, arg, func, options) {\n      var obj = this.clone();\n\n      obj._tests.push({\n        func: func,\n        name: name,\n        arg: arg,\n        options: options\n      });\n\n      return obj;\n    }\n  }, {\n    key: \"_testUnique\",\n    value: function _testUnique(name, arg, func, options) {\n      var obj = this.clone();\n      obj._tests = obj._tests.filter(function (test) {\n        return test.name !== name;\n      });\n\n      obj._tests.push({\n        func: func,\n        name: name,\n        arg: arg,\n        options: options\n      });\n\n      return obj;\n    }\n  }, {\n    key: \"options\",\n    value: function options(_options) {\n      Hoek.assert(!_options.context, 'Cannot override context');\n      this.checkOptions(_options);\n      var obj = this.clone();\n      obj._settings = Settings.concat(obj._settings, _options);\n      return obj;\n    }\n  }, {\n    key: \"strict\",\n    value: function strict(isStrict) {\n      var obj = this.clone();\n      var convert = isStrict === undefined ? false : !isStrict;\n      obj._settings = Settings.concat(obj._settings, {\n        convert: convert\n      });\n      return obj;\n    }\n  }, {\n    key: \"raw\",\n    value: function raw(isRaw) {\n      var value = isRaw === undefined ? true : isRaw;\n\n      if (this._flags.raw === value) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.raw = value;\n      return obj;\n    }\n  }, {\n    key: \"error\",\n    value: function error(err) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        self: false\n      };\n      Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\n      var unknownKeys = Object.keys(options).filter(function (k) {\n        return !['self'].includes(k);\n      });\n      Hoek.assert(unknownKeys.length === 0, \"Options \".concat(unknownKeys, \" are unknown\"));\n      var obj = this.clone();\n      obj._flags.error = err;\n\n      if (options.self) {\n        obj._flags.selfError = true;\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"allow\",\n    value: function allow() {\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n\n      var obj = this.clone();\n      values = Hoek.flatten(values);\n\n      for (var i = 0; i < values.length; ++i) {\n        var value = values[i];\n        Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\n        obj._invalids.remove(value);\n\n        obj._valids.add(value, obj._refs);\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"valid\",\n    value: function valid() {\n      var obj = this.allow.apply(this, arguments);\n      obj._flags.allowOnly = true;\n      return obj;\n    }\n  }, {\n    key: \"invalid\",\n    value: function invalid() {\n      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        values[_key2] = arguments[_key2];\n      }\n\n      var obj = this.clone();\n      values = Hoek.flatten(values);\n\n      for (var i = 0; i < values.length; ++i) {\n        var value = values[i];\n        Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\n        obj._valids.remove(value);\n\n        obj._invalids.add(value, obj._refs);\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"required\",\n    value: function required() {\n      if (this._flags.presence === 'required') {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.presence = 'required';\n      return obj;\n    }\n  }, {\n    key: \"optional\",\n    value: function optional() {\n      if (this._flags.presence === 'optional') {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.presence = 'optional';\n      return obj;\n    }\n  }, {\n    key: \"forbidden\",\n    value: function forbidden() {\n      if (this._flags.presence === 'forbidden') {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.presence = 'forbidden';\n      return obj;\n    }\n  }, {\n    key: \"strip\",\n    value: function strip() {\n      if (this._flags.strip) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.strip = true;\n      return obj;\n    }\n  }, {\n    key: \"applyFunctionToChildren\",\n    value: function applyFunctionToChildren(children, fn) {\n      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var root = arguments.length > 3 ? arguments[3] : undefined;\n      children = [].concat(children);\n\n      if (children.length !== 1 || children[0] !== '') {\n        root = root ? root + '.' : '';\n        var extraChildren = (children[0] === '' ? children.slice(1) : children).map(function (child) {\n          return root + child;\n        });\n        throw new Error('unknown key(s) ' + extraChildren.join(', '));\n      }\n\n      return this[fn].apply(this, _toConsumableArray(args));\n    }\n  }, {\n    key: \"default\",\n    value: function _default(value, description) {\n      if (typeof value === 'function' && !Ref.isRef(value)) {\n        if (!value.description && description) {\n          value.description = description;\n        }\n\n        if (!this._flags.func) {\n          Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\n        }\n      }\n\n      var obj = this.clone();\n      obj._flags.default = value;\n      Ref.push(obj._refs, value);\n      return obj;\n    }\n  }, {\n    key: \"empty\",\n    value: function empty(schema) {\n      var obj = this.clone();\n\n      if (schema === undefined) {\n        delete obj._flags.empty;\n      } else {\n        obj._flags.empty = Cast.schema(this._currentJoi, schema);\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"when\",\n    value: function when(condition, options) {\n      Hoek.assert(options && typeof options === 'object', 'Invalid options');\n      Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n      var then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\n      var otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\n      Alternatives = Alternatives || require('../alternatives');\n      var alternativeOptions = {\n        then: then,\n        otherwise: otherwise\n      };\n\n      if (Object.prototype.hasOwnProperty.call(options, 'is')) {\n        alternativeOptions.is = options.is;\n      }\n\n      var obj = Alternatives.when(condition, alternativeOptions);\n      obj._flags.presence = 'ignore';\n      obj._baseType = this;\n      return obj;\n    }\n  }, {\n    key: \"description\",\n    value: function description(desc) {\n      Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n      var obj = this.clone();\n      obj._description = desc;\n      return obj;\n    }\n  }, {\n    key: \"notes\",\n    value: function notes(_notes) {\n      Hoek.assert(_notes && (typeof _notes === 'string' || Array.isArray(_notes)), 'Notes must be a non-empty string or array');\n      var obj = this.clone();\n      obj._notes = obj._notes.concat(_notes);\n      return obj;\n    }\n  }, {\n    key: \"tags\",\n    value: function tags(_tags) {\n      Hoek.assert(_tags && (typeof _tags === 'string' || Array.isArray(_tags)), 'Tags must be a non-empty string or array');\n      var obj = this.clone();\n      obj._tags = obj._tags.concat(_tags);\n      return obj;\n    }\n  }, {\n    key: \"meta\",\n    value: function meta(_meta) {\n      Hoek.assert(_meta !== undefined, 'Meta cannot be undefined');\n      var obj = this.clone();\n      obj._meta = obj._meta.concat(_meta);\n      return obj;\n    }\n  }, {\n    key: \"example\",\n    value: function example() {\n      Hoek.assert(arguments.length > 0, 'Missing examples');\n      var processed = [];\n\n      for (var i = 0; i < arguments.length; ++i) {\n        var example = [].concat(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n        Hoek.assert(example.length <= 2, \"Bad example format at index \".concat(i));\n        var value = example[0];\n        var options = example[1];\n\n        if (options !== undefined) {\n          Hoek.assert(options && typeof options === 'object', \"Options for example at index \".concat(i, \" must be an object\"));\n          var unknownOptions = Object.keys(options).filter(function (option) {\n            return !['parent', 'context'].includes(option);\n          });\n          Hoek.assert(unknownOptions.length === 0, \"Unknown example options \".concat(unknownOptions, \" at index \").concat(i));\n        } else {\n          options = {};\n        }\n\n        var localState = new State('', [], options.parent || null);\n\n        var result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? {\n          context: options.context\n        } : null));\n\n        Hoek.assert(!result.errors, \"Bad example at index \".concat(i, \":\"), result.errors && Errors.process(result.errors, value));\n        var ex = {\n          value: value\n        };\n\n        if (Object.keys(options).length) {\n          ex.options = options;\n        }\n\n        processed.push(ex);\n      }\n\n      var obj = this.clone();\n      obj._examples = processed;\n      return obj;\n    }\n  }, {\n    key: \"unit\",\n    value: function unit(name) {\n      Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n      var obj = this.clone();\n      obj._unit = name;\n      return obj;\n    }\n  }, {\n    key: \"_prepareEmptyValue\",\n    value: function _prepareEmptyValue(value) {\n      if (typeof value === 'string' && this._flags.trim) {\n        return value.trim();\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_validate\",\n    value: function _validate(value, state, options, reference) {\n      var originalValue = value; // Setup state and settings\n\n      state = state || new State('', [], null, reference);\n\n      if (this._settings) {\n        var isDefaultOptions = options === internals.defaults;\n\n        if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\n          options = this._settings[Symbols.settingsCache];\n        } else {\n          options = Settings.concat(options, this._settings);\n\n          if (isDefaultOptions) {\n            this._settings[Symbols.settingsCache] = options;\n          }\n        }\n      }\n\n      var errors = [];\n\n      if (this._coerce) {\n        var coerced = this._coerce(value, state, options);\n\n        if (coerced.errors) {\n          value = coerced.value;\n          errors = errors.concat(coerced.errors);\n          return this._finalizeValue(value, originalValue, errors, state, options); // Coerced error always aborts early\n        }\n\n        value = coerced.value;\n      }\n\n      if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\n        value = undefined;\n      } // Check presence requirements\n\n\n      var presence = this._flags.presence || options.presence;\n\n      if (presence === 'optional') {\n        if (value === undefined) {\n          var isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\n\n          if (isDeepDefault && this._type === 'object') {\n            value = {};\n          } else {\n            return this._finalizeValue(value, originalValue, errors, state, options);\n          }\n        }\n      } else if (presence === 'required' && value === undefined) {\n        errors.push(this.createError('any.required', null, state, options));\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      } else if (presence === 'forbidden') {\n        if (value === undefined) {\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n\n        errors.push(this.createError('any.unknown', null, state, options));\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      } // Check allowed and denied values using the original value\n\n\n      var match = this._valids.get(value, state, options, this._flags.insensitive);\n\n      if (match) {\n        if (options.convert) {\n          value = match.value;\n        }\n\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      }\n\n      if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n        errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', {\n          value: value,\n          invalids: this._invalids.values({\n            stripUndefined: true\n          })\n        }, state, options));\n\n        if (options.abortEarly) {\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n      } // Convert value and validate type\n\n\n      if (this._base) {\n        var base = this._base(value, state, options);\n\n        if (base.errors) {\n          value = base.value;\n          errors = errors.concat(base.errors);\n          return this._finalizeValue(value, originalValue, errors, state, options); // Base error always aborts early\n        }\n\n        if (base.value !== value) {\n          value = base.value; // Check allowed and denied values using the converted value\n\n          match = this._valids.get(value, state, options, this._flags.insensitive);\n\n          if (match) {\n            value = match.value;\n            return this._finalizeValue(value, originalValue, errors, state, options);\n          }\n\n          if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', {\n              value: value,\n              invalids: this._invalids.values({\n                stripUndefined: true\n              })\n            }, state, options));\n\n            if (options.abortEarly) {\n              return this._finalizeValue(value, originalValue, errors, state, options);\n            }\n          }\n        }\n      } // Required values did not match\n\n\n      if (this._flags.allowOnly) {\n        errors.push(this.createError('any.allowOnly', {\n          value: value,\n          valids: this._valids.values({\n            stripUndefined: true\n          })\n        }, state, options));\n\n        if (options.abortEarly) {\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n      } // Validate tests\n\n\n      for (var i = 0; i < this._tests.length; ++i) {\n        var test = this._tests[i];\n        var ret = test.func.call(this, value, state, options);\n\n        if (ret instanceof Errors.Err) {\n          errors.push(ret);\n\n          if (options.abortEarly) {\n            return this._finalizeValue(value, originalValue, errors, state, options);\n          }\n        } else {\n          value = ret;\n        }\n      }\n\n      return this._finalizeValue(value, originalValue, errors, state, options);\n    }\n  }, {\n    key: \"_finalizeValue\",\n    value: function _finalizeValue(value, originalValue, errors, state, options) {\n      var _this = this;\n\n      var finalValue;\n\n      if (value !== undefined) {\n        finalValue = this._flags.raw ? originalValue : value;\n      } else if (options.noDefaults) {\n        finalValue = value;\n      } else if (Ref.isRef(this._flags.default)) {\n        finalValue = this._flags.default(state.parent, options);\n      } else if (typeof this._flags.default === 'function' && !(this._flags.func && !this._flags.default.description)) {\n        var args;\n\n        if (state.parent !== null && this._flags.default.length > 0) {\n          args = [Hoek.clone(state.parent), options];\n        }\n\n        var defaultValue = internals._try(this._flags.default, args);\n\n        finalValue = defaultValue.value;\n\n        if (defaultValue.error) {\n          errors.push(this.createError('any.default', {\n            error: defaultValue.error\n          }, state, options));\n        }\n      } else {\n        finalValue = Hoek.clone(this._flags.default);\n      }\n\n      if (errors.length && typeof this._flags.error === 'function' && (!this._flags.selfError || errors.some(function (e) {\n        return state.path.length === e.path.length;\n      }))) {\n        var change = this._flags.error.call(this, errors);\n\n        if (typeof change === 'string') {\n          errors = [this.createOverrideError('override', {\n            reason: errors\n          }, state, options, change)];\n        } else {\n          errors = [].concat(change).map(function (err) {\n            return err instanceof Error ? err : _this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\n          });\n        }\n      }\n\n      return {\n        value: this._flags.strip ? undefined : finalValue,\n        finalValue: finalValue,\n        errors: errors.length ? errors : null\n      };\n    }\n  }, {\n    key: \"_validateWithOptions\",\n    value: function _validateWithOptions(value, options, callback) {\n      if (options) {\n        this.checkOptions(options);\n      }\n\n      var settings = Settings.concat(internals.defaults, options);\n\n      var result = this._validate(value, null, settings);\n\n      var errors = Errors.process(result.errors, value);\n\n      if (callback) {\n        return callback(errors, result.value);\n      }\n\n      return {\n        error: errors,\n        value: result.value,\n        then: function then(resolve, reject) {\n          if (errors) {\n            return Promise.reject(errors).catch(reject);\n          }\n\n          return Promise.resolve(result.value).then(resolve);\n        },\n        catch: function _catch(reject) {\n          if (errors) {\n            return Promise.reject(errors).catch(reject);\n          }\n\n          return Promise.resolve(result.value);\n        }\n      };\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(value, options, callback) {\n      if (typeof options === 'function') {\n        return this._validateWithOptions(value, null, options);\n      }\n\n      return this._validateWithOptions(value, options, callback);\n    }\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      var _this2 = this;\n\n      var description = {\n        type: this._type\n      };\n      var flags = Object.keys(this._flags);\n\n      if (flags.length) {\n        if (['empty', 'default', 'lazy', 'label'].some(function (flag) {\n          return _this2._flags.hasOwnProperty(flag);\n        })) {\n          description.flags = {};\n\n          for (var i = 0; i < flags.length; ++i) {\n            var flag = flags[i];\n\n            if (flag === 'empty') {\n              description.flags[flag] = this._flags[flag].describe();\n            } else if (flag === 'default') {\n              if (Ref.isRef(this._flags[flag])) {\n                description.flags[flag] = this._flags[flag].toString();\n              } else if (typeof this._flags[flag] === 'function') {\n                description.flags[flag] = {\n                  description: this._flags[flag].description,\n                  function: this._flags[flag]\n                };\n              } else {\n                description.flags[flag] = this._flags[flag];\n              }\n            } else if (flag === 'lazy' || flag === 'label') {// We don't want it in the description\n            } else {\n              description.flags[flag] = this._flags[flag];\n            }\n          }\n        } else {\n          description.flags = this._flags;\n        }\n      }\n\n      if (this._settings) {\n        description.options = Hoek.clone(this._settings);\n      }\n\n      if (this._baseType) {\n        description.base = this._baseType.describe();\n      }\n\n      if (this._description) {\n        description.description = this._description;\n      }\n\n      if (this._notes.length) {\n        description.notes = this._notes;\n      }\n\n      if (this._tags.length) {\n        description.tags = this._tags;\n      }\n\n      if (this._meta.length) {\n        description.meta = this._meta;\n      }\n\n      if (this._examples.length) {\n        description.examples = this._examples;\n      }\n\n      if (this._unit) {\n        description.unit = this._unit;\n      }\n\n      var valids = this._valids.values();\n\n      if (valids.length) {\n        description.valids = valids.map(function (v) {\n          return Ref.isRef(v) ? v.toString() : v;\n        });\n      }\n\n      var invalids = this._invalids.values();\n\n      if (invalids.length) {\n        description.invalids = invalids.map(function (v) {\n          return Ref.isRef(v) ? v.toString() : v;\n        });\n      }\n\n      description.rules = [];\n\n      for (var _i2 = 0; _i2 < this._tests.length; ++_i2) {\n        var validator = this._tests[_i2];\n        var item = {\n          name: validator.name\n        };\n\n        if (validator.arg !== void 0) {\n          item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\n        }\n\n        var options = validator.options;\n\n        if (options) {\n          if (options.hasRef) {\n            item.arg = {};\n            var keys = Object.keys(validator.arg);\n\n            for (var j = 0; j < keys.length; ++j) {\n              var key = keys[j];\n              var value = validator.arg[key];\n              item.arg[key] = Ref.isRef(value) ? value.toString() : value;\n            }\n          }\n\n          if (typeof options.description === 'string') {\n            item.description = options.description;\n          } else if (typeof options.description === 'function') {\n            item.description = options.description(item.arg);\n          }\n        }\n\n        description.rules.push(item);\n      }\n\n      if (!description.rules.length) {\n        delete description.rules;\n      }\n\n      var label = this._getLabel();\n\n      if (label) {\n        description.label = label;\n      }\n\n      return description;\n    }\n  }, {\n    key: \"label\",\n    value: function label(name) {\n      Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n      var obj = this.clone();\n      obj._flags.label = name;\n      return obj;\n    }\n  }, {\n    key: \"_getLabel\",\n    value: function _getLabel(def) {\n      return this._flags.label || def;\n    }\n  }, {\n    key: \"schemaType\",\n    get: function get() {\n      return this._type;\n    }\n  }]);\n\n  return _class;\n}();\n\ninternals.Any.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects\n// Aliases\n\ninternals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;\ninternals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;\ninternals.Any.prototype.exist = internals.Any.prototype.required;\n\ninternals._try = function (fn) {\n  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var err;\n  var result;\n\n  try {\n    result = fn.apply(void 0, _toConsumableArray(args));\n  } catch (e) {\n    err = e;\n  }\n\n  return {\n    value: result,\n    error: err\n  };\n};","map":{"version":3,"sources":["/home/coeus/Desktop/React/movie-list/node_modules/joi/lib/types/any/index.js"],"names":["Hoek","require","Settings","Ref","Errors","State","Symbols","Alternatives","Cast","Schemas","internals","Set","defaults","abortEarly","convert","allowUnknown","skipFunctions","stripUnknown","language","presence","strip","noDefaults","escapeHtml","module","exports","Any","isJoi","_type","_settings","_valids","_invalids","_tests","_refs","_flags","_description","_unit","_notes","_tags","_examples","_meta","_inner","type","context","state","options","flags","create","message","template","result","validate","error","Error","details","obj","Object","getPrototypeOf","_currentJoi","_baseType","slice","clone","inners","keys","i","length","key","schema","assert","tmpObj","keysToRestore","concat","merge","push","empty","assign","isObject","source","target","j","sourceKey","name","arg","func","filter","test","checkOptions","isStrict","undefined","isRaw","value","raw","err","self","unknownKeys","k","includes","selfError","values","flatten","remove","add","allow","allowOnly","children","fn","args","root","extraChildren","map","child","join","description","isRef","default","condition","then","otherwise","hasOwnProperty","alternativeOptions","prototype","call","is","when","desc","notes","Array","isArray","tags","meta","processed","example","unknownOptions","option","localState","parent","_validate","errors","process","ex","trim","reference","originalValue","isDefaultOptions","settingsCache","_coerce","coerced","_finalizeValue","_prepareEmptyValue","isDeepDefault","createError","match","get","insensitive","has","invalids","stripUndefined","_base","base","valids","ret","Err","finalValue","defaultValue","_try","some","e","path","change","createOverrideError","reason","callback","settings","resolve","reject","Promise","catch","_validateWithOptions","flag","describe","toString","function","examples","unit","v","rules","validator","item","hasRef","label","_getLabel","def","isImmutable","only","equal","valid","disallow","not","invalid","exist","required"],"mappings":"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","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Settings = require('./settings');\nconst Ref = require('../../ref');\nconst Errors = require('../../errors');\nconst State = require('../state');\nconst Symbols = require('../symbols');\n\n// Delay-loaded to prevent circular dependencies\nlet Alternatives = null;\nlet Cast = null;\nlet Schemas = null;\n\n\n// Declare internals\n\nconst internals = {\n    Set: require('../../set')\n};\n\n\ninternals.defaults = {\n    abortEarly: true,\n    convert: true,\n    allowUnknown: false,\n    skipFunctions: false,\n    stripUnknown: false,\n    language: {},\n    presence: 'optional',\n    strip: false,\n    noDefaults: false,\n    escapeHtml: false\n\n    // context: null\n};\n\n\nmodule.exports = internals.Any = class {\n\n    constructor() {\n\n        Cast = Cast || require('../../cast');\n\n        this.isJoi = true;\n        this._type = 'any';\n        this._settings = null;\n        this._valids = new internals.Set();\n        this._invalids = new internals.Set();\n        this._tests = [];\n        this._refs = [];\n        this._flags = {\n            /*\n             presence: 'optional',                   // optional, required, forbidden, ignore\n             allowOnly: false,\n             allowUnknown: undefined,\n             default: undefined,\n             forbidden: false,\n             encoding: undefined,\n             insensitive: false,\n             trim: false,\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\n             case: undefined,                        // upper, lower\n             empty: undefined,\n             func: false,\n             raw: false\n             */\n        };\n\n        this._description = null;\n        this._unit = null;\n        this._notes = [];\n        this._tags = [];\n        this._examples = [];\n        this._meta = [];\n\n        this._inner = {};                           // Hash of arrays of immutable objects\n    }\n\n    _init() {\n\n        return this;\n    }\n\n    get schemaType() {\n\n        return this._type;\n    }\n\n    createError(type, context, state, options, flags = this._flags) {\n\n        return Errors.create(type, context, state, options, flags);\n    }\n\n    createOverrideError(type, context, state, options, message, template) {\n\n        return Errors.create(type, context, state, options, this._flags, message, template);\n    }\n\n    checkOptions(options) {\n\n        Schemas = Schemas || require('../../schemas');\n\n        const result = Schemas.options.validate(options);\n\n        if (result.error) {\n            throw new Error(result.error.details[0].message);\n        }\n    }\n\n    clone() {\n\n        const obj = Object.create(Object.getPrototypeOf(this));\n\n        obj.isJoi = true;\n        obj._currentJoi = this._currentJoi;\n        obj._type = this._type;\n        obj._settings = this._settings;\n        obj._baseType = this._baseType;\n        obj._valids = this._valids.slice();\n        obj._invalids = this._invalids.slice();\n        obj._tests = this._tests.slice();\n        obj._refs = this._refs.slice();\n        obj._flags = Hoek.clone(this._flags);\n\n        obj._description = this._description;\n        obj._unit = this._unit;\n        obj._notes = this._notes.slice();\n        obj._tags = this._tags.slice();\n        obj._examples = this._examples.slice();\n        obj._meta = this._meta.slice();\n\n        obj._inner = {};\n        const inners = Object.keys(this._inner);\n        for (let i = 0; i < inners.length; ++i) {\n            const key = inners[i];\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\n        }\n\n        return obj;\n    }\n\n    concat(schema) {\n\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\n\n        let obj = this.clone();\n\n        if (this._type === 'any' && schema._type !== 'any') {\n\n            // Reset values as if we were \"this\"\n            const tmpObj = schema.clone();\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\n\n            for (let i = 0; i < keysToRestore.length; ++i) {\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\n            }\n\n            obj = tmpObj;\n        }\n\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\n        obj._valids.merge(schema._valids, schema._invalids);\n        obj._invalids.merge(schema._invalids, schema._valids);\n        obj._tests.push(...schema._tests);\n        obj._refs.push(...schema._refs);\n        if (obj._flags.empty && schema._flags.empty) {\n            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\n            const flags = Object.assign({}, schema._flags);\n            delete flags.empty;\n            Hoek.merge(obj._flags, flags);\n        }\n        else if (schema._flags.empty) {\n            obj._flags.empty = schema._flags.empty;\n            const flags = Object.assign({}, schema._flags);\n            delete flags.empty;\n            Hoek.merge(obj._flags, flags);\n        }\n        else {\n            Hoek.merge(obj._flags, schema._flags);\n        }\n\n        obj._description = schema._description || obj._description;\n        obj._unit = schema._unit || obj._unit;\n        obj._notes.push(...schema._notes);\n        obj._tags.push(...schema._tags);\n        obj._examples.push(...schema._examples);\n        obj._meta.push(...schema._meta);\n\n        const inners = Object.keys(schema._inner);\n        const isObject = obj._type === 'object';\n        for (let i = 0; i < inners.length; ++i) {\n            const key = inners[i];\n            const source = schema._inner[key];\n            if (source) {\n                const target = obj._inner[key];\n                if (target) {\n                    if (isObject && key === 'children') {\n                        const keys = {};\n\n                        for (let j = 0; j < target.length; ++j) {\n                            keys[target[j].key] = j;\n                        }\n\n                        for (let j = 0; j < source.length; ++j) {\n                            const sourceKey = source[j].key;\n                            if (keys[sourceKey] >= 0) {\n                                target[keys[sourceKey]] = {\n                                    key: sourceKey,\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\n                                };\n                            }\n                            else {\n                                target.push(source[j]);\n                            }\n                        }\n                    }\n                    else {\n                        obj._inner[key] = obj._inner[key].concat(source);\n                    }\n                }\n                else {\n                    obj._inner[key] = source.slice();\n                }\n            }\n        }\n\n        return obj;\n    }\n\n    _test(name, arg, func, options) {\n\n        const obj = this.clone();\n        obj._tests.push({ func, name, arg, options });\n        return obj;\n    }\n\n    _testUnique(name, arg, func, options) {\n\n        const obj = this.clone();\n        obj._tests = obj._tests.filter((test) => test.name !== name);\n        obj._tests.push({ func, name, arg, options });\n        return obj;\n    }\n\n    options(options) {\n\n        Hoek.assert(!options.context, 'Cannot override context');\n        this.checkOptions(options);\n\n        const obj = this.clone();\n        obj._settings = Settings.concat(obj._settings, options);\n        return obj;\n    }\n\n    strict(isStrict) {\n\n        const obj = this.clone();\n\n        const convert = isStrict === undefined ? false : !isStrict;\n        obj._settings = Settings.concat(obj._settings, { convert });\n        return obj;\n    }\n\n    raw(isRaw) {\n\n        const value = isRaw === undefined ? true : isRaw;\n\n        if (this._flags.raw === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.raw = value;\n        return obj;\n    }\n\n    error(err, options = { self: false }) {\n\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\n\n        const unknownKeys = Object.keys(options).filter((k) => !['self'].includes(k));\n        Hoek.assert(unknownKeys.length === 0, `Options ${unknownKeys} are unknown`);\n\n        const obj = this.clone();\n        obj._flags.error = err;\n\n        if (options.self) {\n            obj._flags.selfError = true;\n        }\n\n        return obj;\n    }\n\n    allow(...values) {\n\n        const obj = this.clone();\n        values = Hoek.flatten(values);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n            obj._invalids.remove(value);\n            obj._valids.add(value, obj._refs);\n        }\n\n        return obj;\n    }\n\n    valid(...values) {\n\n        const obj = this.allow(...values);\n        obj._flags.allowOnly = true;\n        return obj;\n    }\n\n    invalid(...values) {\n\n        const obj = this.clone();\n        values = Hoek.flatten(values);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n            obj._valids.remove(value);\n            obj._invalids.add(value, obj._refs);\n        }\n\n        return obj;\n    }\n\n    required() {\n\n        if (this._flags.presence === 'required') {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.presence = 'required';\n        return obj;\n    }\n\n    optional() {\n\n        if (this._flags.presence === 'optional') {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.presence = 'optional';\n        return obj;\n    }\n\n\n    forbidden() {\n\n        if (this._flags.presence === 'forbidden') {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.presence = 'forbidden';\n        return obj;\n    }\n\n\n    strip() {\n\n        if (this._flags.strip) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.strip = true;\n        return obj;\n    }\n\n    applyFunctionToChildren(children, fn, args = [], root) {\n\n        children = [].concat(children);\n\n        if (children.length !== 1 || children[0] !== '') {\n            root = root ? (root + '.') : '';\n\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\n\n                return root + child;\n            });\n\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\n        }\n\n        return this[fn](...args);\n    }\n\n    default(value, description) {\n\n        if (typeof value === 'function' &&\n            !Ref.isRef(value)) {\n\n            if (!value.description &&\n                description) {\n\n                value.description = description;\n            }\n\n            if (!this._flags.func) {\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\n            }\n        }\n\n        const obj = this.clone();\n        obj._flags.default = value;\n        Ref.push(obj._refs, value);\n        return obj;\n    }\n\n    empty(schema) {\n\n        const obj = this.clone();\n        if (schema === undefined) {\n            delete obj._flags.empty;\n        }\n        else {\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\n        }\n\n        return obj;\n    }\n\n    when(condition, options) {\n\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\n\n        Alternatives = Alternatives || require('../alternatives');\n\n        const alternativeOptions = { then, otherwise };\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\n            alternativeOptions.is = options.is;\n        }\n\n        const obj = Alternatives.when(condition, alternativeOptions);\n        obj._flags.presence = 'ignore';\n        obj._baseType = this;\n\n        return obj;\n    }\n\n    description(desc) {\n\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n\n        const obj = this.clone();\n        obj._description = desc;\n        return obj;\n    }\n\n    notes(notes) {\n\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\n\n        const obj = this.clone();\n        obj._notes = obj._notes.concat(notes);\n        return obj;\n    }\n\n    tags(tags) {\n\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\n\n        const obj = this.clone();\n        obj._tags = obj._tags.concat(tags);\n        return obj;\n    }\n\n    meta(meta) {\n\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\n\n        const obj = this.clone();\n        obj._meta = obj._meta.concat(meta);\n        return obj;\n    }\n\n    example(...examples) {\n\n        Hoek.assert(examples.length > 0, 'Missing examples');\n\n        const processed = [];\n        for (let i = 0; i < examples.length; ++i) {\n            const example = [].concat(examples[i]);\n            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);\n\n            const value = example[0];\n            let options = example[1];\n            if (options !== undefined) {\n                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);\n                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));\n                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);\n            }\n            else {\n                options = {};\n            }\n\n            const localState = new State('', [], options.parent || null);\n            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));\n            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));\n\n            const ex = { value };\n            if (Object.keys(options).length) {\n                ex.options = options;\n            }\n\n            processed.push(ex);\n        }\n\n        const obj = this.clone();\n        obj._examples = processed;\n        return obj;\n    }\n\n    unit(name) {\n\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n\n        const obj = this.clone();\n        obj._unit = name;\n        return obj;\n    }\n\n    _prepareEmptyValue(value) {\n\n        if (typeof value === 'string' && this._flags.trim) {\n            return value.trim();\n        }\n\n        return value;\n    }\n\n    _validate(value, state, options, reference) {\n\n        const originalValue = value;\n\n        // Setup state and settings\n\n        state = state || new State('', [], null, reference);\n\n        if (this._settings) {\n            const isDefaultOptions = options === internals.defaults;\n            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\n                options = this._settings[Symbols.settingsCache];\n            }\n            else {\n                options = Settings.concat(options, this._settings);\n                if (isDefaultOptions) {\n                    this._settings[Symbols.settingsCache] = options;\n                }\n            }\n        }\n\n        let errors = [];\n\n        if (this._coerce) {\n            const coerced = this._coerce(value, state, options);\n            if (coerced.errors) {\n                value = coerced.value;\n                errors = errors.concat(coerced.errors);\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early\n            }\n\n            value = coerced.value;\n        }\n\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\n            value = undefined;\n        }\n\n        // Check presence requirements\n\n        const presence = this._flags.presence || options.presence;\n        if (presence === 'optional') {\n            if (value === undefined) {\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\n                if (isDeepDefault && this._type === 'object') {\n                    value = {};\n                }\n                else {\n                    return this._finalizeValue(value, originalValue, errors, state, options);\n                }\n            }\n        }\n        else if (presence === 'required' &&\n            value === undefined) {\n\n            errors.push(this.createError('any.required', null, state, options));\n            return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n        else if (presence === 'forbidden') {\n            if (value === undefined) {\n                return this._finalizeValue(value, originalValue, errors, state, options);\n            }\n\n            errors.push(this.createError('any.unknown', null, state, options));\n            return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n\n        // Check allowed and denied values using the original value\n\n        let match = this._valids.get(value, state, options, this._flags.insensitive);\n        if (match) {\n            if (options.convert) {\n                value = match.value;\n            }\n\n            return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\n            if (options.abortEarly) {\n\n                return this._finalizeValue(value, originalValue, errors, state, options);\n            }\n        }\n\n        // Convert value and validate type\n\n        if (this._base) {\n            const base = this._base(value, state, options);\n            if (base.errors) {\n                value = base.value;\n                errors = errors.concat(base.errors);\n                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early\n            }\n\n            if (base.value !== value) {\n                value = base.value;\n\n                // Check allowed and denied values using the converted value\n\n                match = this._valids.get(value, state, options, this._flags.insensitive);\n                if (match) {\n                    value = match.value;\n                    return this._finalizeValue(value, originalValue, errors, state, options);\n                }\n\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\n                    if (options.abortEarly) {\n                        return this._finalizeValue(value, originalValue, errors, state, options);\n                    }\n                }\n            }\n        }\n\n        // Required values did not match\n\n        if (this._flags.allowOnly) {\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\n            if (options.abortEarly) {\n                return this._finalizeValue(value, originalValue, errors, state, options);\n            }\n        }\n\n        // Validate tests\n\n        for (let i = 0; i < this._tests.length; ++i) {\n            const test = this._tests[i];\n            const ret = test.func.call(this, value, state, options);\n            if (ret instanceof Errors.Err) {\n                errors.push(ret);\n                if (options.abortEarly) {\n                    return this._finalizeValue(value, originalValue, errors, state, options);\n                }\n            }\n            else {\n                value = ret;\n            }\n        }\n\n        return this._finalizeValue(value, originalValue, errors, state, options);\n    }\n\n    _finalizeValue(value, originalValue, errors, state, options) {\n\n        let finalValue;\n\n        if (value !== undefined) {\n            finalValue = this._flags.raw ? originalValue : value;\n        }\n        else if (options.noDefaults) {\n            finalValue = value;\n        }\n        else if (Ref.isRef(this._flags.default)) {\n            finalValue = this._flags.default(state.parent, options);\n        }\n        else if (typeof this._flags.default === 'function' &&\n            !(this._flags.func && !this._flags.default.description)) {\n\n            let args;\n\n            if (state.parent !== null &&\n                this._flags.default.length > 0) {\n\n                args = [Hoek.clone(state.parent), options];\n            }\n\n            const defaultValue = internals._try(this._flags.default, args);\n            finalValue = defaultValue.value;\n            if (defaultValue.error) {\n                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\n            }\n        }\n        else {\n            finalValue = Hoek.clone(this._flags.default);\n        }\n\n        if (errors.length &&\n            typeof this._flags.error === 'function' &&\n            (\n                !this._flags.selfError ||\n                errors.some((e) => state.path.length === e.path.length)\n            )\n        ) {\n            const change = this._flags.error.call(this, errors);\n\n            if (typeof change === 'string') {\n                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\n            }\n            else {\n                errors = [].concat(change)\n                    .map((err) => {\n\n                        return err instanceof Error ?\n                            err :\n                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\n                    });\n            }\n        }\n\n        return {\n            value: this._flags.strip ? undefined : finalValue,\n            finalValue,\n            errors: errors.length ? errors : null\n        };\n    }\n\n    _validateWithOptions(value, options, callback) {\n\n        if (options) {\n            this.checkOptions(options);\n        }\n\n        const settings = Settings.concat(internals.defaults, options);\n        const result = this._validate(value, null, settings);\n        const errors = Errors.process(result.errors, value);\n\n        if (callback) {\n            return callback(errors, result.value);\n        }\n\n        return {\n            error: errors,\n            value: result.value,\n            then(resolve, reject) {\n\n                if (errors) {\n                    return Promise.reject(errors).catch(reject);\n                }\n\n                return Promise.resolve(result.value).then(resolve);\n            },\n            catch(reject) {\n\n                if (errors) {\n                    return Promise.reject(errors).catch(reject);\n                }\n\n                return Promise.resolve(result.value);\n            }\n        };\n    }\n\n    validate(value, options, callback) {\n\n        if (typeof options === 'function') {\n            return this._validateWithOptions(value, null, options);\n        }\n\n        return this._validateWithOptions(value, options, callback);\n    }\n\n    describe() {\n\n        const description = {\n            type: this._type\n        };\n\n        const flags = Object.keys(this._flags);\n        if (flags.length) {\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\n                description.flags = {};\n                for (let i = 0; i < flags.length; ++i) {\n                    const flag = flags[i];\n                    if (flag === 'empty') {\n                        description.flags[flag] = this._flags[flag].describe();\n                    }\n                    else if (flag === 'default') {\n                        if (Ref.isRef(this._flags[flag])) {\n                            description.flags[flag] = this._flags[flag].toString();\n                        }\n                        else if (typeof this._flags[flag] === 'function') {\n                            description.flags[flag] = {\n                                description: this._flags[flag].description,\n                                function   : this._flags[flag]\n                            };\n                        }\n                        else {\n                            description.flags[flag] = this._flags[flag];\n                        }\n                    }\n                    else if (flag === 'lazy' || flag === 'label') {\n                        // We don't want it in the description\n                    }\n                    else {\n                        description.flags[flag] = this._flags[flag];\n                    }\n                }\n            }\n            else {\n                description.flags = this._flags;\n            }\n        }\n\n        if (this._settings) {\n            description.options = Hoek.clone(this._settings);\n        }\n\n        if (this._baseType) {\n            description.base = this._baseType.describe();\n        }\n\n        if (this._description) {\n            description.description = this._description;\n        }\n\n        if (this._notes.length) {\n            description.notes = this._notes;\n        }\n\n        if (this._tags.length) {\n            description.tags = this._tags;\n        }\n\n        if (this._meta.length) {\n            description.meta = this._meta;\n        }\n\n        if (this._examples.length) {\n            description.examples = this._examples;\n        }\n\n        if (this._unit) {\n            description.unit = this._unit;\n        }\n\n        const valids = this._valids.values();\n        if (valids.length) {\n            description.valids = valids.map((v) => {\n\n                return Ref.isRef(v) ? v.toString() : v;\n            });\n        }\n\n        const invalids = this._invalids.values();\n        if (invalids.length) {\n            description.invalids = invalids.map((v) => {\n\n                return Ref.isRef(v) ? v.toString() : v;\n            });\n        }\n\n        description.rules = [];\n\n        for (let i = 0; i < this._tests.length; ++i) {\n            const validator = this._tests[i];\n            const item = { name: validator.name };\n\n            if (validator.arg !== void 0) {\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\n            }\n\n            const options = validator.options;\n            if (options) {\n                if (options.hasRef) {\n                    item.arg = {};\n                    const keys = Object.keys(validator.arg);\n                    for (let j = 0; j < keys.length; ++j) {\n                        const key = keys[j];\n                        const value = validator.arg[key];\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\n                    }\n                }\n\n                if (typeof options.description === 'string') {\n                    item.description = options.description;\n                }\n                else if (typeof options.description === 'function') {\n                    item.description = options.description(item.arg);\n                }\n            }\n\n            description.rules.push(item);\n        }\n\n        if (!description.rules.length) {\n            delete description.rules;\n        }\n\n        const label = this._getLabel();\n        if (label) {\n            description.label = label;\n        }\n\n        return description;\n    }\n\n    label(name) {\n\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n\n        const obj = this.clone();\n        obj._flags.label = name;\n        return obj;\n    }\n\n    _getLabel(def) {\n\n        return this._flags.label || def;\n    }\n\n};\n\n\ninternals.Any.prototype.isImmutable = true;     // Prevents Hoek from deep cloning schema objects\n\n// Aliases\n\ninternals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;\ninternals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;\ninternals.Any.prototype.exist = internals.Any.prototype.required;\n\n\ninternals._try = function (fn, args = []) {\n\n    let err;\n    let result;\n\n    try {\n        result = fn(...args);\n    }\n    catch (e) {\n        err = e;\n    }\n\n    return {\n        value: result,\n        error: err\n    };\n};\n"]},"metadata":{},"sourceType":"script"}