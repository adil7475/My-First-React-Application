{"ast":null,"code":"'use strict'; // Load modules\n\nvar _toConsumableArray = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/home/coeus/Desktop/React/movie-list/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar Hoek = require('hoek');\n\nvar Any = require('../any');\n\nvar Cast = require('../../cast');\n\nvar Ref = require('../../ref');\n\nvar State = require('../state'); // Declare internals\n\n\nvar internals = {};\n\ninternals.fastSplice = function (arr, i) {\n  var pos = i;\n\n  while (pos < arr.length) {\n    arr[pos++] = arr[pos];\n  }\n\n  --arr.length;\n};\n\ninternals.Array = /*#__PURE__*/function (_Any) {\n  _inherits(_class, _Any);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this));\n    _this._type = 'array';\n    _this._inner.items = [];\n    _this._inner.ordereds = [];\n    _this._inner.inclusions = [];\n    _this._inner.exclusions = [];\n    _this._inner.requireds = [];\n    _this._flags.sparse = false;\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: \"_base\",\n    value: function _base(value, state, options) {\n      var result = {\n        value: value\n      };\n\n      if (typeof value === 'string' && options.convert) {\n        internals.safeParse(value, result);\n      }\n\n      var isArray = Array.isArray(result.value);\n      var wasArray = isArray;\n\n      if (options.convert && this._flags.single && !isArray) {\n        result.value = [result.value];\n        isArray = true;\n      }\n\n      if (!isArray) {\n        result.errors = this.createError('array.base', null, state, options);\n        return result;\n      }\n\n      if (this._inner.inclusions.length || this._inner.exclusions.length || this._inner.requireds.length || this._inner.ordereds.length || !this._flags.sparse) {\n        // Clone the array so that we don't modify the original\n        if (wasArray) {\n          result.value = result.value.slice(0);\n        }\n\n        result.errors = this._checkItems(result.value, wasArray, state, options);\n\n        if (result.errors && wasArray && options.convert && this._flags.single) {\n          // Attempt a 2nd pass by putting the array inside one.\n          var previousErrors = result.errors;\n          result.value = [result.value];\n          result.errors = this._checkItems(result.value, wasArray, state, options);\n\n          if (result.errors) {\n            // Restore previous errors and value since this didn't validate either.\n            result.errors = previousErrors;\n            result.value = result.value[0];\n          }\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_checkItems\",\n    value: function _checkItems(items, wasArray, state, options) {\n      var errors = [];\n      var errored;\n\n      var requireds = this._inner.requireds.slice();\n\n      var ordereds = this._inner.ordereds.slice();\n\n      var inclusions = [].concat(_toConsumableArray(this._inner.inclusions), _toConsumableArray(requireds));\n      var il = items.length;\n\n      for (var i = 0; i < il; ++i) {\n        errored = false;\n        var item = items[i];\n        var isValid = false;\n        var key = wasArray ? i : state.key;\n        var path = wasArray ? [].concat(_toConsumableArray(state.path), [i]) : state.path;\n        var localState = new State(key, path, state.parent, state.reference);\n        var res = void 0; // Sparse\n\n        if (!this._flags.sparse && item === undefined) {\n          errors.push(this.createError('array.sparse', null, {\n            key: state.key,\n            path: localState.path,\n            pos: i\n          }, options));\n\n          if (options.abortEarly) {\n            return errors;\n          }\n\n          ordereds.shift();\n          continue;\n        } // Exclusions\n\n\n        for (var j = 0; j < this._inner.exclusions.length; ++j) {\n          res = this._inner.exclusions[j]._validate(item, localState, {}); // Not passing options to use defaults\n\n          if (!res.errors) {\n            errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', {\n              pos: i,\n              value: item\n            }, {\n              key: state.key,\n              path: localState.path\n            }, options));\n            errored = true;\n\n            if (options.abortEarly) {\n              return errors;\n            }\n\n            ordereds.shift();\n            break;\n          }\n        }\n\n        if (errored) {\n          continue;\n        } // Ordered\n\n\n        if (this._inner.ordereds.length) {\n          if (ordereds.length > 0) {\n            var ordered = ordereds.shift();\n            res = ordered._validate(item, localState, options);\n\n            if (!res.errors) {\n              if (ordered._flags.strip) {\n                internals.fastSplice(items, i);\n                --i;\n                --il;\n              } else if (!this._flags.sparse && res.value === undefined) {\n                errors.push(this.createError('array.sparse', null, {\n                  key: state.key,\n                  path: localState.path,\n                  pos: i\n                }, options));\n\n                if (options.abortEarly) {\n                  return errors;\n                }\n\n                continue;\n              } else {\n                items[i] = res.value;\n              }\n            } else {\n              errors.push(this.createError('array.ordered', {\n                pos: i,\n                reason: res.errors,\n                value: item\n              }, {\n                key: state.key,\n                path: localState.path\n              }, options));\n\n              if (options.abortEarly) {\n                return errors;\n              }\n            }\n\n            continue;\n          } else if (!this._inner.items.length) {\n            errors.push(this.createError('array.orderedLength', {\n              pos: i,\n              limit: this._inner.ordereds.length\n            }, {\n              key: state.key,\n              path: localState.path\n            }, options));\n\n            if (options.abortEarly) {\n              return errors;\n            }\n\n            continue;\n          }\n        } // Requireds\n\n\n        var requiredChecks = [];\n        var jl = requireds.length;\n\n        for (var _j = 0; _j < jl; ++_j) {\n          res = requiredChecks[_j] = requireds[_j]._validate(item, localState, options);\n\n          if (!res.errors) {\n            items[i] = res.value;\n            isValid = true;\n            internals.fastSplice(requireds, _j);\n            --_j;\n            --jl;\n\n            if (!this._flags.sparse && res.value === undefined) {\n              errors.push(this.createError('array.sparse', null, {\n                key: state.key,\n                path: localState.path,\n                pos: i\n              }, options));\n\n              if (options.abortEarly) {\n                return errors;\n              }\n            }\n\n            break;\n          }\n        }\n\n        if (isValid) {\n          continue;\n        } // Inclusions\n\n\n        var stripUnknown = options.stripUnknown && !!options.stripUnknown.arrays || false;\n        jl = inclusions.length;\n\n        for (var _j2 = 0; _j2 < jl; ++_j2) {\n          var inclusion = inclusions[_j2]; // Avoid re-running requireds that already didn't match in the previous loop\n\n          var previousCheck = requireds.indexOf(inclusion);\n\n          if (previousCheck !== -1) {\n            res = requiredChecks[previousCheck];\n          } else {\n            res = inclusion._validate(item, localState, options);\n\n            if (!res.errors) {\n              if (inclusion._flags.strip) {\n                internals.fastSplice(items, i);\n                --i;\n                --il;\n              } else if (!this._flags.sparse && res.value === undefined) {\n                errors.push(this.createError('array.sparse', null, {\n                  key: state.key,\n                  path: localState.path,\n                  pos: i\n                }, options));\n                errored = true;\n              } else {\n                items[i] = res.value;\n              }\n\n              isValid = true;\n              break;\n            }\n          } // Return the actual error if only one inclusion defined\n\n\n          if (jl === 1) {\n            if (stripUnknown) {\n              internals.fastSplice(items, i);\n              --i;\n              --il;\n              isValid = true;\n              break;\n            }\n\n            errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', {\n              pos: i,\n              reason: res.errors,\n              value: item\n            }, {\n              key: state.key,\n              path: localState.path\n            }, options));\n            errored = true;\n\n            if (options.abortEarly) {\n              return errors;\n            }\n\n            break;\n          }\n        }\n\n        if (errored) {\n          continue;\n        }\n\n        if (this._inner.inclusions.length && !isValid) {\n          if (stripUnknown) {\n            internals.fastSplice(items, i);\n            --i;\n            --il;\n            continue;\n          }\n\n          errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', {\n            pos: i,\n            value: item\n          }, {\n            key: state.key,\n            path: localState.path\n          }, options));\n\n          if (options.abortEarly) {\n            return errors;\n          }\n        }\n      }\n\n      if (requireds.length) {\n        this._fillMissedErrors(errors, requireds, state, options);\n      }\n\n      if (ordereds.length) {\n        this._fillOrderedErrors(errors, ordereds, state, options);\n      }\n\n      return errors.length ? errors : null;\n    }\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      var description = _get(_getPrototypeOf(_class.prototype), \"describe\", this).call(this);\n\n      if (this._inner.ordereds.length) {\n        description.orderedItems = [];\n\n        for (var i = 0; i < this._inner.ordereds.length; ++i) {\n          description.orderedItems.push(this._inner.ordereds[i].describe());\n        }\n      }\n\n      if (this._inner.items.length) {\n        description.items = [];\n\n        for (var _i = 0; _i < this._inner.items.length; ++_i) {\n          description.items.push(this._inner.items[_i].describe());\n        }\n      }\n\n      if (description.rules) {\n        for (var _i2 = 0; _i2 < description.rules.length; ++_i2) {\n          var rule = description.rules[_i2];\n\n          if (rule.name === 'has') {\n            rule.arg = rule.arg.describe();\n          }\n        }\n      }\n\n      return description;\n    }\n  }, {\n    key: \"items\",\n    value: function items() {\n      var _this2 = this;\n\n      var obj = this.clone();\n\n      for (var _len = arguments.length, schemas = new Array(_len), _key = 0; _key < _len; _key++) {\n        schemas[_key] = arguments[_key];\n      }\n\n      Hoek.flatten(schemas).forEach(function (type, index) {\n        try {\n          type = Cast.schema(_this2._currentJoi, type);\n        } catch (castErr) {\n          if (castErr.hasOwnProperty('path')) {\n            castErr.path = index + '.' + castErr.path;\n          } else {\n            castErr.path = index;\n          }\n\n          castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n          throw castErr;\n        }\n\n        obj._inner.items.push(type);\n\n        if (type._flags.presence === 'required') {\n          obj._inner.requireds.push(type);\n        } else if (type._flags.presence === 'forbidden') {\n          obj._inner.exclusions.push(type.optional());\n        } else {\n          obj._inner.inclusions.push(type);\n        }\n      });\n      return obj;\n    }\n  }, {\n    key: \"ordered\",\n    value: function ordered() {\n      var _this3 = this;\n\n      var obj = this.clone();\n\n      for (var _len2 = arguments.length, schemas = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        schemas[_key2] = arguments[_key2];\n      }\n\n      Hoek.flatten(schemas).forEach(function (type, index) {\n        try {\n          type = Cast.schema(_this3._currentJoi, type);\n        } catch (castErr) {\n          if (castErr.hasOwnProperty('path')) {\n            castErr.path = index + '.' + castErr.path;\n          } else {\n            castErr.path = index;\n          }\n\n          castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n          throw castErr;\n        }\n\n        obj._inner.ordereds.push(type);\n      });\n      return obj;\n    }\n  }, {\n    key: \"min\",\n    value: function min(limit) {\n      var isRef = Ref.isRef(limit);\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n      return this._testUnique('min', limit, function (value, state, options) {\n        var compareTo;\n\n        if (isRef) {\n          compareTo = limit(state.reference || state.parent, options);\n\n          if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n            return this.createError('array.ref', {\n              ref: limit,\n              value: compareTo\n            }, state, options);\n          }\n        } else {\n          compareTo = limit;\n        }\n\n        if (value.length >= compareTo) {\n          return value;\n        }\n\n        return this.createError('array.min', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"max\",\n    value: function max(limit) {\n      var isRef = Ref.isRef(limit);\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n      return this._testUnique('max', limit, function (value, state, options) {\n        var compareTo;\n\n        if (isRef) {\n          compareTo = limit(state.reference || state.parent, options);\n\n          if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n            return this.createError('array.ref', {\n              ref: limit.key\n            }, state, options);\n          }\n        } else {\n          compareTo = limit;\n        }\n\n        if (value.length <= compareTo) {\n          return value;\n        }\n\n        return this.createError('array.max', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"length\",\n    value: function length(limit) {\n      var isRef = Ref.isRef(limit);\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n      return this._testUnique('length', limit, function (value, state, options) {\n        var compareTo;\n\n        if (isRef) {\n          compareTo = limit(state.reference || state.parent, options);\n\n          if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n            return this.createError('array.ref', {\n              ref: limit.key\n            }, state, options);\n          }\n        } else {\n          compareTo = limit;\n        }\n\n        if (value.length === compareTo) {\n          return value;\n        }\n\n        return this.createError('array.length', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"has\",\n    value: function has(schema) {\n      try {\n        schema = Cast.schema(this._currentJoi, schema);\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n        }\n\n        throw castErr;\n      }\n\n      return this._test('has', schema, function (value, state, options) {\n        var isValid = value.some(function (item, idx) {\n          var localState = new State(idx, [].concat(_toConsumableArray(state.path), [idx]), state.key, state.reference);\n          return !schema._validate(item, localState, options).errors;\n        });\n\n        if (isValid) {\n          return value;\n        }\n\n        var patternLabel = schema._getLabel();\n\n        if (patternLabel) {\n          return this.createError('array.hasKnown', {\n            patternLabel: patternLabel\n          }, state, options);\n        }\n\n        return this.createError('array.hasUnknown', null, state, options);\n      });\n    }\n  }, {\n    key: \"unique\",\n    value: function unique(comparator, configs) {\n      Hoek.assert(comparator === undefined || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');\n      Hoek.assert(configs === undefined || typeof configs === 'object', 'configs must be an object');\n      var settings = {\n        ignoreUndefined: configs && configs.ignoreUndefined || false\n      };\n\n      if (typeof comparator === 'string') {\n        settings.path = comparator;\n      } else if (typeof comparator === 'function') {\n        settings.comparator = comparator;\n      }\n\n      return this._test('unique', settings, function (value, state, options) {\n        var found = {\n          string: Object.create(null),\n          number: Object.create(null),\n          undefined: Object.create(null),\n          boolean: Object.create(null),\n          object: new Map(),\n          function: new Map(),\n          custom: new Map()\n        };\n        var compare = settings.comparator || Hoek.deepEqual;\n        var ignoreUndefined = settings.ignoreUndefined;\n\n        for (var i = 0; i < value.length; ++i) {\n          var item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];\n          var records = settings.comparator ? found.custom : found[typeof item]; // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.\n          // I still want to keep the test for future js versions with new types (eg. Symbol).\n\n          if (\n          /* $lab:coverage:off$ */\n          records\n          /* $lab:coverage:on$ */\n          ) {\n              if (records instanceof Map) {\n                var entries = records.entries();\n                var current = void 0;\n\n                while (!(current = entries.next()).done) {\n                  if (compare(current.value[0], item)) {\n                    var localState = new State(state.key, [].concat(_toConsumableArray(state.path), [i]), state.parent, state.reference);\n                    var context = {\n                      pos: i,\n                      value: value[i],\n                      dupePos: current.value[1],\n                      dupeValue: value[current.value[1]]\n                    };\n\n                    if (settings.path) {\n                      context.path = settings.path;\n                    }\n\n                    return this.createError('array.unique', context, localState, options);\n                  }\n                }\n\n                records.set(item, i);\n              } else {\n                if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {\n                  var _localState = new State(state.key, [].concat(_toConsumableArray(state.path), [i]), state.parent, state.reference);\n\n                  var _context = {\n                    pos: i,\n                    value: value[i],\n                    dupePos: records[item],\n                    dupeValue: value[records[item]]\n                  };\n\n                  if (settings.path) {\n                    _context.path = settings.path;\n                  }\n\n                  return this.createError('array.unique', _context, _localState, options);\n                }\n\n                records[item] = i;\n              }\n            }\n        }\n\n        return value;\n      });\n    }\n  }, {\n    key: \"sparse\",\n    value: function sparse(enabled) {\n      var value = enabled === undefined ? true : !!enabled;\n\n      if (this._flags.sparse === value) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.sparse = value;\n      return obj;\n    }\n  }, {\n    key: \"single\",\n    value: function single(enabled) {\n      var value = enabled === undefined ? true : !!enabled;\n\n      if (this._flags.single === value) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.single = value;\n      return obj;\n    }\n  }, {\n    key: \"_fillMissedErrors\",\n    value: function _fillMissedErrors(errors, requireds, state, options) {\n      var knownMisses = [];\n      var unknownMisses = 0;\n\n      for (var i = 0; i < requireds.length; ++i) {\n        var label = requireds[i]._getLabel();\n\n        if (label) {\n          knownMisses.push(label);\n        } else {\n          ++unknownMisses;\n        }\n      }\n\n      if (knownMisses.length) {\n        if (unknownMisses) {\n          errors.push(this.createError('array.includesRequiredBoth', {\n            knownMisses: knownMisses,\n            unknownMisses: unknownMisses\n          }, {\n            key: state.key,\n            path: state.path\n          }, options));\n        } else {\n          errors.push(this.createError('array.includesRequiredKnowns', {\n            knownMisses: knownMisses\n          }, {\n            key: state.key,\n            path: state.path\n          }, options));\n        }\n      } else {\n        errors.push(this.createError('array.includesRequiredUnknowns', {\n          unknownMisses: unknownMisses\n        }, {\n          key: state.key,\n          path: state.path\n        }, options));\n      }\n    }\n  }, {\n    key: \"_fillOrderedErrors\",\n    value: function _fillOrderedErrors(errors, ordereds, state, options) {\n      var requiredOrdereds = [];\n\n      for (var i = 0; i < ordereds.length; ++i) {\n        var presence = Hoek.reach(ordereds[i], '_flags.presence');\n\n        if (presence === 'required') {\n          requiredOrdereds.push(ordereds[i]);\n        }\n      }\n\n      if (requiredOrdereds.length) {\n        this._fillMissedErrors(errors, requiredOrdereds, state, options);\n      }\n    }\n  }]);\n\n  return _class;\n}(Any);\n\ninternals.safeParse = function (value, result) {\n  try {\n    var converted = JSON.parse(value);\n\n    if (Array.isArray(converted)) {\n      result.value = converted;\n    }\n  } catch (e) {}\n};\n\nmodule.exports = new internals.Array();","map":{"version":3,"sources":["/home/coeus/Desktop/React/movie-list/node_modules/joi/lib/types/array/index.js"],"names":["Hoek","require","Any","Cast","Ref","State","internals","fastSplice","arr","i","pos","length","Array","_type","_inner","items","ordereds","inclusions","exclusions","requireds","_flags","sparse","value","state","options","result","convert","safeParse","isArray","wasArray","single","errors","createError","slice","_checkItems","previousErrors","errored","il","item","isValid","key","path","localState","parent","reference","res","undefined","push","abortEarly","shift","j","_validate","ordered","strip","reason","limit","requiredChecks","jl","stripUnknown","arrays","inclusion","previousCheck","indexOf","_fillMissedErrors","_fillOrderedErrors","description","orderedItems","describe","rules","rule","name","arg","obj","clone","schemas","flatten","forEach","type","index","schema","_currentJoi","castErr","hasOwnProperty","message","presence","optional","isRef","assert","Number","isSafeInteger","_testUnique","compareTo","ref","_test","some","idx","patternLabel","_getLabel","comparator","configs","settings","ignoreUndefined","found","string","Object","create","number","boolean","object","Map","function","custom","compare","deepEqual","reach","records","entries","current","next","done","context","dupePos","dupeValue","set","enabled","knownMisses","unknownMisses","label","requiredOrdereds","converted","JSON","parse","e","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\n\nconst Any = require('../any');\nconst Cast = require('../../cast');\nconst Ref = require('../../ref');\nconst State = require('../state');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.fastSplice = function (arr, i) {\n\n    let pos = i;\n    while (pos < arr.length) {\n        arr[pos++] = arr[pos];\n    }\n\n    --arr.length;\n};\n\n\ninternals.Array = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'array';\n        this._inner.items = [];\n        this._inner.ordereds = [];\n        this._inner.inclusions = [];\n        this._inner.exclusions = [];\n        this._inner.requireds = [];\n        this._flags.sparse = false;\n    }\n\n    _base(value, state, options) {\n\n        const result = {\n            value\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            internals.safeParse(value, result);\n        }\n\n        let isArray = Array.isArray(result.value);\n        const wasArray = isArray;\n        if (options.convert && this._flags.single && !isArray) {\n            result.value = [result.value];\n            isArray = true;\n        }\n\n        if (!isArray) {\n            result.errors = this.createError('array.base', null, state, options);\n            return result;\n        }\n\n        if (this._inner.inclusions.length ||\n            this._inner.exclusions.length ||\n            this._inner.requireds.length ||\n            this._inner.ordereds.length ||\n            !this._flags.sparse) {\n\n            // Clone the array so that we don't modify the original\n            if (wasArray) {\n                result.value = result.value.slice(0);\n            }\n\n            result.errors = this._checkItems(result.value, wasArray, state, options);\n\n            if (result.errors && wasArray && options.convert && this._flags.single) {\n\n                // Attempt a 2nd pass by putting the array inside one.\n                const previousErrors = result.errors;\n\n                result.value = [result.value];\n                result.errors = this._checkItems(result.value, wasArray, state, options);\n\n                if (result.errors) {\n\n                    // Restore previous errors and value since this didn't validate either.\n                    result.errors = previousErrors;\n                    result.value = result.value[0];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    _checkItems(items, wasArray, state, options) {\n\n        const errors = [];\n        let errored;\n\n        const requireds = this._inner.requireds.slice();\n        const ordereds = this._inner.ordereds.slice();\n        const inclusions = [...this._inner.inclusions, ...requireds];\n\n        let il = items.length;\n        for (let i = 0; i < il; ++i) {\n            errored = false;\n            const item = items[i];\n            let isValid = false;\n            const key = wasArray ? i : state.key;\n            const path = wasArray ? [...state.path, i] : state.path;\n            const localState = new State(key, path, state.parent, state.reference);\n            let res;\n\n            // Sparse\n\n            if (!this._flags.sparse && item === undefined) {\n                errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                if (options.abortEarly) {\n                    return errors;\n                }\n\n                ordereds.shift();\n\n                continue;\n            }\n\n            // Exclusions\n\n            for (let j = 0; j < this._inner.exclusions.length; ++j) {\n                res = this._inner.exclusions[j]._validate(item, localState, {});                // Not passing options to use defaults\n\n                if (!res.errors) {\n                    errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));\n                    errored = true;\n\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n\n                    ordereds.shift();\n\n                    break;\n                }\n            }\n\n            if (errored) {\n                continue;\n            }\n\n            // Ordered\n            if (this._inner.ordereds.length) {\n                if (ordereds.length > 0) {\n                    const ordered = ordereds.shift();\n                    res = ordered._validate(item, localState, options);\n                    if (!res.errors) {\n                        if (ordered._flags.strip) {\n                            internals.fastSplice(items, i);\n                            --i;\n                            --il;\n                        }\n                        else if (!this._flags.sparse && res.value === undefined) {\n                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                            if (options.abortEarly) {\n                                return errors;\n                            }\n\n                            continue;\n                        }\n                        else {\n                            items[i] = res.value;\n                        }\n                    }\n                    else {\n                        errors.push(this.createError('array.ordered', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));\n                        if (options.abortEarly) {\n                            return errors;\n                        }\n                    }\n\n                    continue;\n                }\n                else if (!this._inner.items.length) {\n                    errors.push(this.createError('array.orderedLength', { pos: i, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n\n                    continue;\n                }\n            }\n\n            // Requireds\n\n            const requiredChecks = [];\n            let jl = requireds.length;\n            for (let j = 0; j < jl; ++j) {\n                res = requiredChecks[j] = requireds[j]._validate(item, localState, options);\n                if (!res.errors) {\n                    items[i] = res.value;\n                    isValid = true;\n                    internals.fastSplice(requireds, j);\n                    --j;\n                    --jl;\n\n                    if (!this._flags.sparse && res.value === undefined) {\n                        errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                        if (options.abortEarly) {\n                            return errors;\n                        }\n                    }\n\n                    break;\n                }\n            }\n\n            if (isValid) {\n                continue;\n            }\n\n            // Inclusions\n\n            const stripUnknown = options.stripUnknown && !!options.stripUnknown.arrays || false;\n\n            jl = inclusions.length;\n            for (let j = 0; j < jl; ++j) {\n                const inclusion = inclusions[j];\n\n                // Avoid re-running requireds that already didn't match in the previous loop\n                const previousCheck = requireds.indexOf(inclusion);\n                if (previousCheck !== -1) {\n                    res = requiredChecks[previousCheck];\n                }\n                else {\n                    res = inclusion._validate(item, localState, options);\n\n                    if (!res.errors) {\n                        if (inclusion._flags.strip) {\n                            internals.fastSplice(items, i);\n                            --i;\n                            --il;\n                        }\n                        else if (!this._flags.sparse && res.value === undefined) {\n                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n                            errored = true;\n                        }\n                        else {\n                            items[i] = res.value;\n                        }\n\n                        isValid = true;\n                        break;\n                    }\n                }\n\n                // Return the actual error if only one inclusion defined\n                if (jl === 1) {\n                    if (stripUnknown) {\n                        internals.fastSplice(items, i);\n                        --i;\n                        --il;\n                        isValid = true;\n                        break;\n                    }\n\n                    errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));\n                    errored = true;\n\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n\n                    break;\n                }\n            }\n\n            if (errored) {\n                continue;\n            }\n\n            if (this._inner.inclusions.length && !isValid) {\n                if (stripUnknown) {\n                    internals.fastSplice(items, i);\n                    --i;\n                    --il;\n                    continue;\n                }\n\n                errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));\n\n                if (options.abortEarly) {\n                    return errors;\n                }\n            }\n        }\n\n        if (requireds.length) {\n            this._fillMissedErrors(errors, requireds, state, options);\n        }\n\n        if (ordereds.length) {\n            this._fillOrderedErrors(errors, ordereds, state, options);\n        }\n\n        return errors.length ? errors : null;\n    }\n\n    describe() {\n\n        const description = super.describe();\n\n        if (this._inner.ordereds.length) {\n            description.orderedItems = [];\n\n            for (let i = 0; i < this._inner.ordereds.length; ++i) {\n                description.orderedItems.push(this._inner.ordereds[i].describe());\n            }\n        }\n\n        if (this._inner.items.length) {\n            description.items = [];\n\n            for (let i = 0; i < this._inner.items.length; ++i) {\n                description.items.push(this._inner.items[i].describe());\n            }\n        }\n\n        if (description.rules) {\n            for (let i = 0; i < description.rules.length; ++i) {\n                const rule = description.rules[i];\n                if (rule.name === 'has') {\n                    rule.arg = rule.arg.describe();\n                }\n            }\n        }\n\n        return description;\n    }\n\n    items(...schemas) {\n\n        const obj = this.clone();\n\n        Hoek.flatten(schemas).forEach((type, index) => {\n\n            try {\n                type = Cast.schema(this._currentJoi, type);\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = index + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = index;\n                }\n\n                castErr.message = `${castErr.message}(${castErr.path})`;\n                throw castErr;\n            }\n\n            obj._inner.items.push(type);\n\n            if (type._flags.presence === 'required') {\n                obj._inner.requireds.push(type);\n            }\n            else if (type._flags.presence === 'forbidden') {\n                obj._inner.exclusions.push(type.optional());\n            }\n            else {\n                obj._inner.inclusions.push(type);\n            }\n        });\n\n        return obj;\n    }\n\n    ordered(...schemas) {\n\n        const obj = this.clone();\n\n        Hoek.flatten(schemas).forEach((type, index) => {\n\n            try {\n                type = Cast.schema(this._currentJoi, type);\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = index + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = index;\n                }\n\n                castErr.message = `${castErr.message}(${castErr.path})`;\n                throw castErr;\n            }\n\n            obj._inner.ordereds.push(type);\n        });\n\n        return obj;\n    }\n\n    min(limit) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n\n        return this._testUnique('min', limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n                    return this.createError('array.ref', { ref: limit, value: compareTo }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (value.length >= compareTo) {\n                return value;\n            }\n\n            return this.createError('array.min', { limit, value }, state, options);\n        });\n    }\n\n    max(limit) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n\n        return this._testUnique('max', limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n                    return this.createError('array.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (value.length <= compareTo) {\n                return value;\n            }\n\n            return this.createError('array.max', { limit, value }, state, options);\n        });\n    }\n\n    length(limit) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n\n        return this._testUnique('length', limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n                    return this.createError('array.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (value.length === compareTo) {\n                return value;\n            }\n\n            return this.createError('array.length', { limit, value }, state, options);\n        });\n    }\n\n    has(schema) {\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = `${castErr.message}(${castErr.path})`;\n            }\n\n            throw castErr;\n        }\n\n        return this._test('has', schema, function (value, state, options) {\n\n            const isValid = value.some((item, idx) => {\n\n                const localState = new State(idx, [...state.path, idx], state.key, state.reference);\n                return !schema._validate(item, localState, options).errors;\n            });\n\n            if (isValid) {\n                return value;\n            }\n\n            const patternLabel = schema._getLabel();\n            if (patternLabel) {\n                return this.createError('array.hasKnown', { patternLabel }, state, options);\n            }\n\n            return this.createError('array.hasUnknown', null, state, options);\n        });\n    }\n\n    unique(comparator, configs) {\n\n        Hoek.assert(comparator === undefined ||\n            typeof comparator === 'function' ||\n            typeof comparator === 'string', 'comparator must be a function or a string');\n\n        Hoek.assert(configs === undefined ||\n            typeof configs === 'object', 'configs must be an object');\n\n        const settings = {\n            ignoreUndefined: (configs && configs.ignoreUndefined) || false\n        };\n\n\n        if (typeof comparator === 'string') {\n            settings.path = comparator;\n        }\n        else if (typeof comparator === 'function') {\n            settings.comparator = comparator;\n        }\n\n        return this._test('unique', settings, function (value, state, options) {\n\n            const found = {\n                string: Object.create(null),\n                number: Object.create(null),\n                undefined: Object.create(null),\n                boolean: Object.create(null),\n                object: new Map(),\n                function: new Map(),\n                custom: new Map()\n            };\n\n            const compare = settings.comparator || Hoek.deepEqual;\n            const ignoreUndefined = settings.ignoreUndefined;\n\n            for (let i = 0; i < value.length; ++i) {\n                const item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];\n                const records = settings.comparator ? found.custom : found[typeof item];\n\n                // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.\n                // I still want to keep the test for future js versions with new types (eg. Symbol).\n                if (/* $lab:coverage:off$ */ records /* $lab:coverage:on$ */) {\n                    if (records instanceof Map) {\n                        const entries = records.entries();\n                        let current;\n                        while (!(current = entries.next()).done) {\n                            if (compare(current.value[0], item)) {\n                                const localState = new State(state.key, [...state.path, i], state.parent, state.reference);\n                                const context = {\n                                    pos: i,\n                                    value: value[i],\n                                    dupePos: current.value[1],\n                                    dupeValue: value[current.value[1]]\n                                };\n\n                                if (settings.path) {\n                                    context.path = settings.path;\n                                }\n\n                                return this.createError('array.unique', context, localState, options);\n                            }\n                        }\n\n                        records.set(item, i);\n                    }\n                    else {\n                        if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {\n                            const localState = new State(state.key, [...state.path, i], state.parent, state.reference);\n\n                            const context = {\n                                pos: i,\n                                value: value[i],\n                                dupePos: records[item],\n                                dupeValue: value[records[item]]\n                            };\n\n                            if (settings.path) {\n                                context.path = settings.path;\n                            }\n\n                            return this.createError('array.unique', context, localState, options);\n                        }\n\n                        records[item] = i;\n                    }\n                }\n            }\n\n            return value;\n        });\n    }\n\n    sparse(enabled) {\n\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.sparse === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.sparse = value;\n        return obj;\n    }\n\n    single(enabled) {\n\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.single === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.single = value;\n        return obj;\n    }\n\n    _fillMissedErrors(errors, requireds, state, options) {\n\n        const knownMisses = [];\n        let unknownMisses = 0;\n        for (let i = 0; i < requireds.length; ++i) {\n            const label = requireds[i]._getLabel();\n            if (label) {\n                knownMisses.push(label);\n            }\n            else {\n                ++unknownMisses;\n            }\n        }\n\n        if (knownMisses.length) {\n            if (unknownMisses) {\n                errors.push(this.createError('array.includesRequiredBoth', { knownMisses, unknownMisses }, { key: state.key, path: state.path }, options));\n            }\n            else {\n                errors.push(this.createError('array.includesRequiredKnowns', { knownMisses }, { key: state.key, path: state.path }, options));\n            }\n        }\n        else {\n            errors.push(this.createError('array.includesRequiredUnknowns', { unknownMisses }, { key: state.key, path: state.path }, options));\n        }\n    }\n\n\n    _fillOrderedErrors(errors, ordereds, state, options) {\n\n        const requiredOrdereds = [];\n\n        for (let i = 0; i < ordereds.length; ++i) {\n            const presence = Hoek.reach(ordereds[i], '_flags.presence');\n            if (presence === 'required') {\n                requiredOrdereds.push(ordereds[i]);\n            }\n        }\n\n        if (requiredOrdereds.length) {\n            this._fillMissedErrors(errors, requiredOrdereds, state, options);\n        }\n    }\n\n};\n\n\ninternals.safeParse = function (value, result) {\n\n    try {\n        const converted = JSON.parse(value);\n        if (Array.isArray(converted)) {\n            result.value = converted;\n        }\n    }\n    catch (e) { }\n};\n\n\nmodule.exports = new internals.Array();\n"]},"metadata":{},"sourceType":"script"}